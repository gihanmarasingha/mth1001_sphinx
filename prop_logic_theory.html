
<!DOCTYPE html>

<html>
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. The Theory of Propositional Logic &#8212; MTH1001 in Lean 1.00 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/proof.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Propositional Logic Lean Summary" href="prop_logic_lean_summary.html" />
    <link rel="prev" title="MTH1001 in Lean" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="the-theory-of-propositional-logic">
<span id="sec-prop-logic-tutorial"></span><h1><span class="section-number">1. </span>The Theory of Propositional Logic<a class="headerlink" href="#the-theory-of-propositional-logic" title="Permalink to this headline">&#182;</a></h1>
<div class="section" id="propositions-and-propositional-variables">
<h2><span class="section-number">1.1. </span>Propositions and propositional variables<a class="headerlink" href="#propositions-and-propositional-variables" title="Permalink to this headline">&#182;</a></h2>
<p>From an informal perspective, propositions are statements that can be assigned
a truth value.</p>
<p>From the formal perspective, which is more useful when you want to prove a theorem, propositions are
simply expressions that can be constructed recursively by applying connectives to other propositions.</p>
<p>As with any recursive definition, we must begin with a base set of propositions. These are called
<em>propositional variables</em>. Technically, we have an infinite list of propositional variables,
labelled <span class="math notranslate nohighlight">\(P_1, P_2, \dots, P_n, \dots\)</span>. For practical purposes, we often refer to
propositional variables using different letters of the alphabet whether uppercase <span class="math notranslate nohighlight">\(P, Q, R, \dots\)</span>
or lower case <span class="math notranslate nohighlight">\(p, q, r, \dots\)</span>.</p>
<p>The five connectives of propositional logic are shown in
<a class="reference internal" href="#tab-prop-connectives"><span class="std std-numref">Table 1.1</span></a>, listed in decreasing order of precedence. Negation is a unary
connective, which means that it applies only to one proposition. The remaining connectives are
binary, applying to two propositions.</p>
<span id="tab-prop-connectives"></span><table class="colwidths-given docutils align-default" id="id8">
<caption><span class="caption-number">Table 1.1 </span><span class="caption-text">Connectives of propositional logic and their order of precedence</span><a class="headerlink" href="#id8" title="Permalink to this table">&#182;</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Connective</p></th>
<th class="head"><p>Name</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\neg\)</span></p></td>
<td><p>Negation</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\land\)</span></p></td>
<td><p>Conjunction, And</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\lor\)</span></p></td>
<td><p>Disjunction, Or</p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\to\)</span></p></td>
<td><p>Implication</p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\leftrightarrow\)</span></p></td>
<td><p>If and only if</p></td>
</tr>
</tbody>
</table>
<div class="proof proof-type-definition" id="id9">

    <div class="proof-title">
        <span class="proof-type">Definition 1.1</span>
        
            <span class="proof-title-name">(Proposition)</span>
        
    </div><div class="proof-content">
<p>A proposition is a propositional variable or one of <span class="math notranslate nohighlight">\((\neg \alpha)\)</span>, <span class="math notranslate nohighlight">\((\alpha\land\beta)\)</span>,
<span class="math notranslate nohighlight">\((\alpha\lor\beta)\)</span>, <span class="math notranslate nohighlight">\((\alpha\to\beta)\)</span>, <span class="math notranslate nohighlight">\((\alpha\leftrightarrow\beta)\)</span>, where
<span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are propositions.</p>
</div></div><p>For example, if our propositional variables are <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span>, then all the
following are propositions: <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\((\neg P)\)</span>, <span class="math notranslate nohighlight">\((\neg(P\land Q))\)</span>,
<span class="math notranslate nohighlight">\(((P\lor Q)\leftrightarrow(\neg R))\)</span>.</p>
<p>To simplify writing propositions, we may always remove the outermost parentheses and remove other
parentheses according to the order of precedence. That is, if <span class="math notranslate nohighlight">\(\oplus\)</span>
and <span class="math notranslate nohighlight">\(\otimes\)</span> are (generic) connectives where <span class="math notranslate nohighlight">\(\oplus\)</span> has a higher order of precedence
than <span class="math notranslate nohighlight">\(\otimes\)</span>, if  <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, and <span class="math notranslate nohighlight">\(\gamma\)</span>
are propositions, then <span class="math notranslate nohighlight">\(((\alpha\oplus\beta)\otimes\gamma)\)</span> can be replaced with
<span class="math notranslate nohighlight">\(\alpha\oplus\beta\otimes\gamma\)</span>. Likewise, <span class="math notranslate nohighlight">\((\alpha\otimes(\beta\oplus\gamma))\)</span> can
be replaced with <span class="math notranslate nohighlight">\(\alpha\otimes\beta\oplus\gamma\)</span>. This rule can be applied recursively.</p>
<p>Thus <span class="math notranslate nohighlight">\(((P\land Q)\to(P\lor(Q\land(\neg R))))\)</span> can be more simply written as
<span class="math notranslate nohighlight">\(P\land Q \to P \lor Q \land \neg R\)</span>.</p>
<p>The proposition, <span class="math notranslate nohighlight">\(((P\land Q)\lor R)\)</span> can be written as <span class="math notranslate nohighlight">\((P\land Q)\lor R\)</span>, but we
cannot remove the inner parentheses as the connective <span class="math notranslate nohighlight">\(\lor\)</span> has a lower order of precendence
than <span class="math notranslate nohighlight">\(\land\)</span>.</p>
<p>Two propositions <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are considered to be equal if and only if they
are written <em>identically</em>, with the exception of parenthesis dropping as described in the previous
paragraph.</p>
<p>Thus <span class="math notranslate nohighlight">\(P\land Q\)</span> is <em>not</em> equal to <span class="math notranslate nohighlight">\(Q\land P\)</span>. However, <span class="math notranslate nohighlight">\(((P\land Q)\lor R)\)</span> is
equal to <span class="math notranslate nohighlight">\((P\land Q)\lor R\)</span> and to <span class="math notranslate nohighlight">\(P\land Q \lor R\)</span>.</p>
<p>In <a class="reference internal" href="prop_logic_lean_summary.html#prop-variables"><span class="std std-numref">Section 2.1</span></a>, we discuss how to represent propositions in Lean.</p>
</div>
<div class="section" id="derivations-and-rules-of-inference">
<h2><span class="section-number">1.2. </span>Derivations and rules of inference<a class="headerlink" href="#derivations-and-rules-of-inference" title="Permalink to this headline">&#182;</a></h2>
<p>Propositional logic is concerned with making derivations, based on <em>premises</em>, using
<em>rules of inference</em>.</p>
<p>Each premise takes the form <span class="math notranslate nohighlight">\(h : \alpha\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is any symbol (usually a lowercase
letter, with or without a subscript) and <span class="math notranslate nohighlight">\(\alpha\)</span> is a proposition.</p>
<p>Intuitively, the judgment <span class="math notranslate nohighlight">\(h : \alpha\)</span> is to be read &#8216;<span class="math notranslate nohighlight">\(h\)</span> is a proof of <span class="math notranslate nohighlight">\(\alpha\)</span>&#8217;.
We will give a more rigorous interpretation of this judgment in <a class="reference internal" href="pred_logic.html#sec-types"><span class="std std-numref">Section 3.1</span></a>.</p>
<p>Here is an example of a rule of inference. This rule is called left conjunction elimination.</p>
<blockquote>
<div><p>Given <span class="math notranslate nohighlight">\(h : P\land Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P\)</span>.</p>
</div></blockquote>
<p>In essence, a rule of inference is a black box that takes certain inputs (the premises) and
produces an output. In this case, the output is a proof of <span class="math notranslate nohighlight">\(P\)</span>. Here, and in every
statement of a rule of interfence, the names of propositions that appear are to be treated as
generic. Thus <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> can be replaced with any propositions.</p>
<p>As an example application of this rule of inference, suppose we have a premise
<span class="math notranslate nohighlight">\(h : (P\to Q)\land R\)</span>. Left conjunction elimination, applied to <span class="math notranslate nohighlight">\(h\)</span>, produces a
proof of <span class="math notranslate nohighlight">\(P\to Q\)</span>.</p>
<p>Rules of inference can be applied in sequence. Suppose we have a premise
<span class="math notranslate nohighlight">\(k_1 : (Q \land P) \land R\)</span>. Applling left conjunction elimination to <span class="math notranslate nohighlight">\(k_1\)</span> gives a proof
of <span class="math notranslate nohighlight">\(Q\land P\)</span>. Let us denote by <span class="math notranslate nohighlight">\(k_2\)</span> the proof of <span class="math notranslate nohighlight">\(Q\land P\)</span> that results from
the application of left conjunction elimination to <span class="math notranslate nohighlight">\(k_1\)</span>. By applying left conjunction
elimination to the hypothesis <span class="math notranslate nohighlight">\(k_2\)</span>, we have a proof of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>We use the word <em>hypothesis</em> to denote either a premise or a result derived by a rule of inference
during the course of a proof. At any stage in a proof, the entire set of hypotheses developed or
introduced up to that point, together with any variables, is called the <em>context</em>. In the above
proof, the context initially consists of thepremise <span class="math notranslate nohighlight">\(k_1\)</span> and the varialbles <span class="math notranslate nohighlight">\(P\)</span>,
<span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span>. After the first application of left conjunction elimination, the context
will also include the hypotheses <span class="math notranslate nohighlight">\(k_2\)</span>.</p>
</div>
<div class="section" id="conjunction">
<h2><span class="section-number">1.3. </span>Conjunction<a class="headerlink" href="#conjunction" title="Permalink to this headline">&#182;</a></h2>
<div class="section" id="conjunction-elimination">
<h3><span class="section-number">1.3.1. </span>Conjunction elimination<a class="headerlink" href="#conjunction-elimination" title="Permalink to this headline">&#182;</a></h3>
<p>There are two conjunction elimination rules, left and right.</p>
<div class="proof proof-type-mathsrule" id="id10">

    <div class="proof-title">
        <span class="proof-type">Rule 1.2</span>
        
            <span class="proof-title-name">(Conjunction elimination)</span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>(<em>Left and elimination</em>) given <span class="math notranslate nohighlight">\(h : P \land Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P\)</span>.</p></li>
<li><p>(<em>Right and elimination</em>) given <span class="math notranslate nohighlight">\(h : P \land Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(Q\)</span>.</p></li>
</ul>
</div></div><p>As an example, given that <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> are propositions, we will deduce <span class="math notranslate nohighlight">\(Q\)</span> from
the premise <span class="math notranslate nohighlight">\(h : (P \land Q)\land R\)</span>.</p>
<blockquote>
<div><p>We have <span class="math notranslate nohighlight">\(h_2 : P\land Q\)</span> by left conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>. The result follows
by right conjunction elimination on <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
</div></blockquote>
</div>
<div class="section" id="conjunction-elimination-in-lean">
<h3><span class="section-number">1.3.2. </span>Conjunction elimination in Lean<a class="headerlink" href="#conjunction-elimination-in-lean" title="Permalink to this headline">&#182;</a></h3>
<p>This is expressed in Lean as follows.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A%0Aexample%20(h%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%20)%20%3A%20q%20%3A%3D%0Abegin%0A%20%20have%20h%E2%82%82%20%3A%20p%20%E2%88%A7%20q%2C%20from%20h.left%2C%0A%20%20exact%20h%E2%82%82.right%0Aend" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_146.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span> <span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span> <span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h&#8322;.right</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">exact</span></code> tactic is a &#8216;finishing command&#8217; that closes the goal with the supplied proof term.
Here, <code class="docutils literal notranslate"><span class="pre">h.left</span></code> is the proof term that results from applying left conjunction elimination to <code class="docutils literal notranslate"><span class="pre">h</span></code>.
The <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic introduces a new goal, in this case <code class="docutils literal notranslate"><span class="pre">h&#8322;</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>. It should be followed by
a tactic that closes the goal. Here, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">h.left</span></code> is a synonym for <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">h.left</span></code>.</p>
<p>In the above proof, <code class="docutils literal notranslate"><span class="pre">h&#8322;.right</span></code> is the proof term that results from applying conjunction
elimination to <code class="docutils literal notranslate"><span class="pre">h&#8322;</span></code>. As <code class="docutils literal notranslate"><span class="pre">h&#8322;</span></code> is a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code>, we have that <code class="docutils literal notranslate"><span class="pre">h&#8322;.right</span></code> is a proof of <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
<p>Tactic-style Lean proofs are designed to be worked with <em>interactively</em>, not to be read. If you are
reading this online, click <em>try it</em> above to open the code snippet in a browser window. Note that
the first time you press <em>try it!</em>, a copy of Lean will be downloaded to your browser. This may take a
few minutes.</p>
<p>At each point in the proof, Lean displays the <em>goal</em> (that which you are trying to prove) and the <em>context</em>
in a separate pane of your window.</p>
<p>At the start of the proof above, Lean will display the following, indicating that the context
consists of three propositional variables, <code class="docutils literal notranslate"><span class="pre">p`,</span> <span class="pre">``q</span></code>, and <code class="docutils literal notranslate"><span class="pre">r</span></code>, together with the premise
<code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">(p</span> <span class="pre">&#8743;</span> <span class="pre">q)</span> <span class="pre">&#8743;</span> <span class="pre">r</span></code>. The goal (indicated with the <em>turnstile</em> symbol <code class="docutils literal notranslate"><span class="pre">&#8866;</span></code>) is that of proving <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=p%20q%20r%20%3A%20Prop%2C%0Ah%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%0A%E2%8A%A2%20q" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_176.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span>
<span class="bp">&#8866;</span> <span class="n">q</span>
</pre></div>
</div>
</div><p>If you place your cursor after the line with the <code class="docutils literal notranslate"><span class="pre">have</span></code> statement, the context changes to the
following, in which <code class="docutils literal notranslate"><span class="pre">h&#8322;</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span></code> has been added.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=p%20q%20r%20%3A%20Prop%2C%0Ah%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%2C%0Ah%E2%82%82%20%3A%20p%20%E2%88%A7%20q%0A%E2%8A%A2%20q" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_185.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">,</span>
<span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">,</span>
<span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span>
<span class="bp">&#8866;</span> <span class="n">q</span>
</pre></div>
</div>
</div><p>To make the proof more readable, you can use the <code class="docutils literal notranslate"><span class="pre">show</span></code> tactic. This tactic announces what
remains to be proved. Below, we follow <code class="docutils literal notranslate"><span class="pre">show</span> <span class="pre">q,</span></code> with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">h&#8322;.right</span></code>, which is a synonym
for <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">h&#8322;.right</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%20)%20%3A%20q%20%3A%3D%0Abegin%0A%20%20have%20h%E2%82%82%20%3A%20p%20%E2%88%A7%20q%2C%20from%20h.left%2C%0A%20%20show%20q%2C%20from%20h%E2%82%82.right%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_196.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span> <span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8322;.right</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The above is a Lean representation of the following mathematical proof.</p>
<blockquote>
<div><p>We have <span class="math notranslate nohighlight">\(h_2 : P\land Q\)</span> by left conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>. We show <span class="math notranslate nohighlight">\(q\)</span>
by right conjunction elimination on <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
</div></blockquote>
<p>Rather than introducing an intermediate hypothesis <code class="docutils literal notranslate"><span class="pre">h&#8322;</span></code>, the proof can be carried out in one line.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r)%20%3A%20q%20%3A%3D%0Abegin%0A%20%20show%20q%2C%20from%20(h.left).right%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_214.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="o">(</span><span class="n">h.left</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>If a Lean proof can be accomplished with one tactic, one need not use a <code class="docutils literal notranslate"><span class="pre">begin</span></code> &#8230; <code class="docutils literal notranslate"><span class="pre">end</span></code> block
but can instead write the tactic after <code class="docutils literal notranslate"><span class="pre">by</span></code>, as below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r)%20%3A%20q%20%3A%3D%0Aby%20exact%20(h.left).right%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_227.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">exact</span> <span class="o">(</span><span class="n">h.left</span><span class="o">)</span><span class="bp">.</span><span class="n">right</span>
</pre></div>
</div>
</div><p>This can be written mathematically as follows.</p>
<blockquote>
<div><p>The result follows by right conjunction elimination applied to the result of left conjunction
elimination applied to <span class="math notranslate nohighlight">\(h\)</span>.</p>
</div></blockquote>
<p>Alternatively, we can use the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic, which performs left and right and elimination
simultaneously.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r)%20%3A%20q%20%3A%3D%0Abegin%0A%20%20cases%20h%20with%20h%E2%82%82%20h%E2%82%83%2C%20--%20We%20have%20%60h%E2%82%82%20%3A%20p%60%20and%20%60h%E2%82%83%20%3A%20q%60%20by%20left%20and%20right%20conjunction%20elimination%20on%20%60h%60.%0A%20%20exact%20h%E2%82%82.right%20%20%20%20%20%20--%20The%20result%20follows%20by%20right%20conjunction%20elimination%20on%20%60h%E2%82%82%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_243.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8322;</span> <span class="n">h&#8323;</span><span class="o">,</span> <span class="c1">-- We have `h&#8322; : p` and `h&#8323; : q` by left and right conjunction elimination on `h`.</span>
  <span class="n">exact</span> <span class="n">h&#8322;.right</span>      <span class="c1">-- The result follows by right conjunction elimination on `h&#8322;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>A mathematical statement of this proof would be:</p>
<p>This can be written mathematically as follows.</p>
<blockquote>
<div><p>We have <span class="math notranslate nohighlight">\(h_2 : p \land q\)</span> and <span class="math notranslate nohighlight">\(h_3 : r\)</span> by left and right conjunction elimination,
respectively, on <span class="math notranslate nohighlight">\(h\)</span>. The result follows by right conjunction elimination on <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
</div></blockquote>
</div>
<div class="section" id="conjunction-introduction">
<h3><span class="section-number">1.3.3. </span>Conjunction introduction<a class="headerlink" href="#conjunction-introduction" title="Permalink to this headline">&#182;</a></h3>
<p>The rule of conjunction introduction can be expressed in two forms, forward and backward.</p>
<div class="proof proof-type-mathsrule" id="id11">

    <div class="proof-title">
        <span class="proof-type">Rule 1.3</span>
        
            <span class="proof-title-name">(Conjunction introduction, forward)</span>
        
    </div><div class="proof-content">
<p>Given <span class="math notranslate nohighlight">\(h_1 : P\)</span> and <span class="math notranslate nohighlight">\(h_2 : Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P\land Q\)</span>.</p>
</div></div><div class="proof proof-type-mathsrule" id="id12">

    <div class="proof-title">
        <span class="proof-type">Rule 1.4</span>
        
            <span class="proof-title-name">(Conjunction introduction, backward)</span>
        
    </div><div class="proof-content">
<p>To prove <span class="math notranslate nohighlight">\(P\land Q\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>.</p>
</div></div><div class="proof proof-type-example" id="id13">
<span id="example-and-comm1"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.5</span>
        
            <span class="proof-title-name">(Commutativity of conjunction (I))</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : P \land Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(Q \land P\)</span>.</p>
</div></div><p>We&#8217;ll give both a forward and a backward proof.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Forward Proof)</span>
        
    </div><div class="proof-content">
<p>We have <span class="math notranslate nohighlight">\(h_2 : P\)</span> and <span class="math notranslate nohighlight">\(h_3 : Q\)</span> by left and right conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.
The result follows by conjunction introduction on <span class="math notranslate nohighlight">\(h_3\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
</div></div><p>Lean uses <code class="docutils literal notranslate"><span class="pre">and.intro</span></code> to represent forward conjunction introduction.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20have%20h%E2%82%82%20%3A%20p%2C%20from%20h.left%2C%0A%20%20have%20h%E2%82%83%20%3A%20q%2C%20from%20h.right%2C%0A%20%20exact%20and.intro%20h%E2%82%83%20h%E2%82%82%2C%0Aend%0A--%20END%0A%0AAlternatively%2C%20one%20can%20use%20the%20'anonymous%20constructor'%20notation%20%60%60%E2%9F%A8h%E2%82%83%2C%20h%E2%82%82%E2%9F%A9%60%60%20in%20place%20of%0A%60%60and.intro%20h%E2%82%83%20h%E2%82%82%60%60.%20Here%2C%20%60%60%E2%9F%A8%60%60%20and%20%60%60%E2%9F%A9%60%60%20are%20written%20as%20%60%60%5C%3C%60%60%20and%20%60%60%5C%3E%60%60%20respectively." target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_289.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.intro</span> <span class="n">h&#8323;</span> <span class="n">h&#8322;</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Backward Proof)</span>
        
    </div><div class="proof-content">
<p>By conjunction introduction, it suffices to prove 1. <span class="math notranslate nohighlight">\(Q\)</span> and 2. <span class="math notranslate nohighlight">\(P\)</span>.</p>
<ol class="arabic simple">
<li><p>We show <span class="math notranslate nohighlight">\(Q\)</span> from right conjunction introduction on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(P\)</span> from left conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span></p></li>
</ol>
</div></div><p>Lean uses <code class="docutils literal notranslate"><span class="pre">split</span></code> to represent backward conjunction introduction. As used below, the <code class="docutils literal notranslate"><span class="pre">split</span></code>
tactic replaces the goal of proving <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code> with two goals 1. to prove <code class="docutils literal notranslate"><span class="pre">q</span></code> and 2. to prove <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20split%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20and%20introduction%2C%20it%20suffices%20to%20prove%20both%20%60q%60%20and%20%60p%60.%0A%20%20show%20q%2C%20from%20h.right%2C%20--%20We%20show%20%60q%60%20by%20right%20and%20elimination%20on%20%60h%60.%0A%20%20show%20p%2C%20from%20h.left%2C%20%20--%20We%20show%20%60p%60%20by%20left%20and%20elimination%20on%20%60h%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_314.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>                <span class="c1">-- By and introduction, it suffices to prove both `q` and `p`.</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span> <span class="c1">-- We show `q` by right and elimination on `h`.</span>
  <span class="k">show</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>  <span class="c1">-- We show `p` by left and elimination on `h`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>If a rule of inference introduces multiple goals, it is good practice (though not required)
to enclose the proof of each new goal in braces. For good measure, I throw in a <code class="docutils literal notranslate"><span class="pre">show</span></code>
at the start of the proof to demonstrate that <code class="docutils literal notranslate"><span class="pre">show</span></code> need not be followed by a tactic that
immediately closes the goal (such as <code class="docutils literal notranslate"><span class="pre">from</span></code> or <code class="docutils literal notranslate"><span class="pre">exact</span></code>). Here, the scope of <code class="docutils literal notranslate"><span class="pre">show</span></code> is the
entire proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20show%20q%20%E2%88%A7%20p%2C%20split%2C%0A%20%20%7B%20show%20q%2C%20from%20h.right%2C%20%7D%2C%0A%20%20%7B%20show%20p%2C%20from%20h.left%2C%20%7D%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_332.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">show</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><div class="section" id="associativity-of-conjunction-in-parts">
<h4><span class="section-number">1.3.3.1. </span>Associativity of conjunction, in parts<a class="headerlink" href="#associativity-of-conjunction-in-parts" title="Permalink to this headline">&#182;</a></h4>
<div class="proof proof-type-example" id="id14">
<span id="example-and-assoc1-0"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.6</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : (P \land Q)\land R\)</span>, we
have a proof of <span class="math notranslate nohighlight">\(P \land (Q\land R)\)</span>.</p>
</div></div><p>Here&#8217;s a forward proof.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>We have <span class="math notranslate nohighlight">\(h_2 : P\land Q\)</span> and <span class="math notranslate nohighlight">\(h_3 : R\)</span> by left and right conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p>We have <span class="math notranslate nohighlight">\(h_4 : P\)</span> and <span class="math notranslate nohighlight">\(h_5 : Q\)</span> by left and right conjunction elimination on <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
<li><p>We have <span class="math notranslate nohighlight">\(h_6 : Q \land R\)</span> by conjunction introduction on <span class="math notranslate nohighlight">\(h_5\)</span> and <span class="math notranslate nohighlight">\(h_3\)</span>.</p></li>
<li><p>The result follows by conjunction introduction on <span class="math notranslate nohighlight">\(h_4\)</span> and <span class="math notranslate nohighlight">\(h_6\)</span>.</p></li>
</ul>
</div></div><p>The same proof can be represented in Lean. In the last line below (just to show that we can), we
we the anonymous constructor notation to express conjunction introduction.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r)%20%3A%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r)%20%3A%3D%0Abegin%0A%20%20cases%20h%20with%20h%E2%82%82%20h%E2%82%83%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20We%20have%20%60h%E2%82%82%20%3A%20(p%20%E2%88%A7%20q)%60%2C%20%60h%E2%82%83%20%3A%20r%60%20by%20left%20%26%20right%20and%20elim.%20on%20%60h%60.%0A%20%20cases%20h%E2%82%82%20with%20h%E2%82%84%20h%E2%82%85%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20We%20have%20%60h%E2%82%84%20%3A%20p%60%20and%20%60h%E2%82%85%20%3A%20q%60%20by%20left%20%26%20right%20and%20elim.%20on%20%60h%E2%82%82%60.%0A%20%20have%20h%E2%82%86%20%3A%20q%20%E2%88%A7%20r%2C%20from%20and.intro%20h%E2%82%85%20h%E2%82%83%2C%20%20--%20We%20have%20%60h%E2%82%86%20%3A%20q%20%E2%88%A7%20r%60%20by%20and%20introduction%20on%20%60h%E2%82%85%60%20and%20%60h%E2%82%83%60.%0A%20%20show%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r)%2C%20from%20%E2%9F%A8h%E2%82%84%2C%20h%E2%82%86%E2%9F%A9%2C%20%20%20%20%20%20%20%20%20--%20We%20show%20%60p%20%E2%88%A7%20(q%20%E2%88%A7%20r)%60%20by%20and%20introduction%20on%20%60h%E2%82%84%60%20and%20%60h%E2%82%86%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_369.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8322;</span> <span class="n">h&#8323;</span><span class="o">,</span>                     <span class="c1">-- We have `h&#8322; : (p &#8743; q)`, `h&#8323; : r` by left &amp; right and elim. on `h`.</span>
  <span class="n">cases</span> <span class="n">h&#8322;</span> <span class="k">with</span> <span class="n">h&#8324;</span> <span class="n">h&#8325;</span><span class="o">,</span>                    <span class="c1">-- We have `h&#8324; : p` and `h&#8325; : q` by left &amp; right and elim. on `h&#8322;`.</span>
  <span class="k">have</span> <span class="n">h&#8326;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.intro</span> <span class="n">h&#8325;</span> <span class="n">h&#8323;</span><span class="o">,</span>  <span class="c1">-- We have `h&#8326; : q &#8743; r` by and introduction on `h&#8325;` and `h&#8323;`.</span>
  <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span> <span class="o">&#10216;</span><span class="n">h&#8324;</span><span class="o">,</span> <span class="n">h&#8326;</span><span class="o">&#10217;,</span>         <span class="c1">-- We show `p &#8743; (q &#8743; r)` by and introduction on `h&#8324;` and `h&#8326;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Here&#8217;s a proof of <a class="reference internal" href="#example-and-assoc1-0"><span class="std std-numref">Example 1.6</span></a> that combines forward and backward reasoning.
reasoning. The reiteration tactic is discussed more fully in
<a class="reference internal" href="#sec-reiteration"><span class="std std-numref">Section 1.4</span></a>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>We have <span class="math notranslate nohighlight">\(h_2 : P\land Q\)</span> and <span class="math notranslate nohighlight">\(h_3 : R\)</span> by left and right conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p>By conjunction introduction, it suffices to prove 1. <span class="math notranslate nohighlight">\(P\)</span> and 2. <span class="math notranslate nohighlight">\(Q \land R\)</span>.</p>
<ol class="arabic simple">
<li><p>We show <span class="math notranslate nohighlight">\(P\)</span> from left conjunction elimination on <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(Q\land R\)</span>. By conjunction introduction, it suffices to show 1. <span class="math notranslate nohighlight">\(Q\)</span> and 2. <span class="math notranslate nohighlight">\(R\)</span>.</p>
<ol class="loweralpha simple">
<li><p>We show <span class="math notranslate nohighlight">\(Q\)</span> from right conjunction elimination on <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(R\)</span> by reiteration on <span class="math notranslate nohighlight">\(h_3\)</span>.</p></li>
</ol>
</li>
</ol>
</li>
</ul>
</div></div><p>This proof can also be represented in Lean.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r)%20%3A%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r)%20%3A%3D%0Abegin%0A%20%20cases%20h%20with%20h%E2%82%82%20h%E2%82%83%2C%20%20%20%20%20%20%20%20%20%20%20--%20We%20have%20%60h%E2%82%82%20%3A%20p%20%E2%88%A7%20q%60%20and%20%60h%E2%82%83%20%3A%20r%60%20by%20left%20and%20right%20conjunction%20elimination%20on%20%60h%60.%0A%20%20split%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20conjunction%20introduction%2C%20it%20suffices%20to%20prove%20%60p%60%20and%20%60q%20%E2%88%A7%20r%60.%0A%20%20%7B%20show%20p%2C%20from%20h%E2%82%82.left%2C%20%7D%2C%20%20%20%20--%20We%20show%20%60p%60%20by%20left%20and%20elimination%20on%20%60h%E2%82%82%60.%0A%20%20%7B%20show%20q%20%E2%88%A7%20r%2C%20split%2C%20%20%20%20%20%20%20%20%20%20--%20We%20show%20%60q%20%E2%88%A7%20r%60.%20By%20conjunction%20introduction%2C%20it%20suffices%20to%20prove%20%60q%60%20and%20%60r%60.%0A%20%20%20%20%7B%20show%20q%2C%20from%20h%E2%82%82.right%2C%20%7D%2C%20--%20We%20show%20%60q%60%20by%20right%20and%20elimination%20on%20%60h%E2%82%82%60.%0A%20%20%20%20%7B%20show%20r%2C%20from%20h%E2%82%83%20%7D%2C%20%7D%20%2C%20%20%20%20--%20We%20show%20%60r%60%20by%20reiteration%20on%20%60h%E2%82%83%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_402.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8322;</span> <span class="n">h&#8323;</span><span class="o">,</span>           <span class="c1">-- We have `h&#8322; : p &#8743; q` and `h&#8323; : r` by left and right conjunction elimination on `h`.</span>
  <span class="n">split</span><span class="o">,</span>                        <span class="c1">-- By conjunction introduction, it suffices to prove `p` and `q &#8743; r`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8322;.left</span><span class="o">,</span> <span class="o">},</span>    <span class="c1">-- We show `p` by left and elimination on `h&#8322;`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">,</span> <span class="n">split</span><span class="o">,</span>          <span class="c1">-- We show `q &#8743; r`. By conjunction introduction, it suffices to prove `q` and `r`.</span>
    <span class="o">{</span> <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8322;.right</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- We show `q` by right and elimination on `h&#8322;`.</span>
    <span class="o">{</span> <span class="k">show</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8323;</span> <span class="o">},</span> <span class="o">}</span> <span class="o">,</span>    <span class="c1">-- We show `r` by reiteration on `h&#8323;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Of course, associativity also works in the other direction.</p>
<div class="proof proof-type-example" id="id15">
<span id="example-and-assoc2-0"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.7</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : P \land (Q\land R)\)</span>,
we have a proof of <span class="math notranslate nohighlight">\((P \land Q)\land R\)</span>.</p>
</div></div><p>Here is an (incomplete) forward proof. Fill in each &#8216;sorry&#8217; to complete the proof.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>We have <span class="math notranslate nohighlight">\(h_2 : P\)</span> and <span class="math notranslate nohighlight">\(h_3 : \text{sorry}\)</span> by sorry on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p>We have <span class="math notranslate nohighlight">\(h_4 : \text{sorry}\)</span> and <span class="math notranslate nohighlight">\(h_5 : R\)</span> by left and right conjunction elimination on <span class="math notranslate nohighlight">\(h_3\)</span>.</p></li>
<li><p>We have <span class="math notranslate nohighlight">\(h_6 : P \land Q\)</span> by sorry.</p></li>
<li><p>The result follows by sorry.</p></li>
</ul>
</div></div><p>Likewise, fill in each <code class="docutils literal notranslate"><span class="pre">sorry</span></code> to complete the forward Lean proof below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r))%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%20%3A%3D%0Abegin%0A%20%20cases%20h%20with%20h%E2%82%82%20h%E2%82%83%2C%0A%20%20cases%20h%E2%82%83%20with%20h%E2%82%84%20h%E2%82%85%2C%0A%20%20have%20h%E2%82%86%20%3A%20p%20%E2%88%A7%20q%2C%20from%20sorry%2C%0A%20%20sorry%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_441.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8322;</span> <span class="n">h&#8323;</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h&#8323;</span> <span class="k">with</span> <span class="n">h&#8324;</span> <span class="n">h&#8325;</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h&#8326;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>As an exercise, replace each sorry below to give a mixed forward and backward proof of
<a class="reference internal" href="#example-and-assoc2-0"><span class="std std-numref">Example 1.7</span></a>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>We have <span class="math notranslate nohighlight">\(h_2 : P\)</span> and <span class="math notranslate nohighlight">\(h_3 : \text{sorry}\)</span> by sorry on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p>By conjunction introduction, it suffices to prove 1. sorry and 2. sorry.</p>
<ol class="arabic simple">
<li><p>sorry</p></li>
<li><p>sorry</p></li>
</ol>
</li>
</ul>
</div></div><p>Likewise, fill in each <code class="docutils literal notranslate"><span class="pre">sorry</span></code> to complete the forward and backward Lean proof below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r))%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%20%3A%3D%0Abegin%0A%20%20cases%20h%20with%20h%E2%82%82%20h%E2%82%83%2C%0A%20%20split%2C%0A%20%20%7B%20split%2C%0A%20%20%20%20%7B%20sorry%2C%20%7D%2C%0A%20%20%20%20%7B%20sorry%2C%20%7D%2C%20%7D%2C%0A%20%20%7B%20sorry%2C%20%7D%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_469.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">))</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8322;</span> <span class="n">h&#8323;</span><span class="o">,</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">split</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>
</div>
<div class="section" id="reiteration">
<span id="sec-reiteration"></span><h2><span class="section-number">1.4. </span>Reiteration<a class="headerlink" href="#reiteration" title="Permalink to this headline">&#182;</a></h2>
<div class="proof proof-type-mathsrule" id="id16">

    <div class="proof-title">
        <span class="proof-type">Rule 1.8</span>
        
            <span class="proof-title-name">(Reiteration)</span>
        
    </div><div class="proof-content">
<p>Given <span class="math notranslate nohighlight">\(P\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P\)</span>.</p>
</div></div><p>Reiteration is a slighly unusual rule. Though we can often avoid using reiteration, it is
required in proving statements such as <span class="math notranslate nohighlight">\(P \to P\)</span>.</p>
<p>For the moment, we present a silly example in which we use reiteration, albeit needlessly.</p>
<div class="proof proof-type-example" id="id17">

    <div class="proof-title">
        <span class="proof-type">Example 1.9</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : P \land Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>We have <span class="math notranslate nohighlight">\(h_2 : Q\)</span> by right conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.
The result follows by reiteration on <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
</div></div><p>Reiteration is represented in Lean via the <code class="docutils literal notranslate"><span class="pre">exact</span></code> (or <code class="docutils literal notranslate"><span class="pre">from</span></code>) tactic applied to an
already-deduced proof term. The code below shows a Lean representation of the proof above.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%3A%3D%0Abegin%0A%20%20have%20h%E2%82%82%20%3A%20q%2C%20from%20h.right%2C%20--%20We%20have%20%60h%E2%82%82%20%3A%20q%60%20by%20right%20and%20elimination%20on%20%60h%60.%0A%20%20exact%20h%E2%82%82%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20The%20result%20follows%20by%20reiteration%20on%20%60h%E2%82%82%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_510.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span> <span class="c1">-- We have `h&#8322; : q` by right and elimination on `h`.</span>
  <span class="n">exact</span> <span class="n">h&#8322;</span><span class="o">,</span>                  <span class="c1">-- The result follows by reiteration on `h&#8322;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>A more verbose mathematical proof concludes by reminding the reader of the goal. Below, for example,
we write, &#8216;We show <span class="math notranslate nohighlight">\(Q\)</span> by &#8230;&#8217; in place of &#8216;The result follows by &#8230;&#8217;.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>We have <span class="math notranslate nohighlight">\(h_2 : Q\)</span> by right conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.
We show <span class="math notranslate nohighlight">\(Q\)</span> by reiteration on <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
</div></div><p>The Lean equivalent is the combination of the <code class="docutils literal notranslate"><span class="pre">show</span></code> and <code class="docutils literal notranslate"><span class="pre">from</span></code> tactics.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A7%20q)%20%3A%20q%20%3A%3D%0Abegin%0A%20%20have%20h%E2%82%82%20%3A%20q%2C%20from%20h.right%2C%20--%20We%20have%20%60h%E2%82%82%20%3A%20q%60%20by%20right%20and%20elimination%20on%20%60h%60.%0A%20%20show%20q%2C%20from%20h%E2%82%82%2C%20%20%20%20%20%20%20%20%20%20%20--%20We%20show%20%60q%60%20by%20reiteration%20on%20%60h%E2%82%82%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_531.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span> <span class="c1">-- We have `h&#8322; : q` by right and elimination on `h`.</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8322;</span><span class="o">,</span>           <span class="c1">-- We show `q` by reiteration on `h&#8322;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="implication">
<h2><span class="section-number">1.5. </span>Implication<a class="headerlink" href="#implication" title="Permalink to this headline">&#182;</a></h2>
<p>The <em>conditional</em> connective <span class="math notranslate nohighlight">\(\to\)</span> is read &#8216;implies&#8217;.
The proposition <span class="math notranslate nohighlight">\(P \to Q\)</span> can be read either as &#8216;<span class="math notranslate nohighlight">\(P\)</span> implies <span class="math notranslate nohighlight">\(Q\)</span>&#8217; or as
&#8216;if <span class="math notranslate nohighlight">\(P\)</span>, then <span class="math notranslate nohighlight">\(Q\)</span>&#8217;.</p>
<p>In a proposition of the form <span class="math notranslate nohighlight">\(P \to Q\)</span>, the proposition <span class="math notranslate nohighlight">\(P\)</span> is called the <em>antecedent</em>
and <span class="math notranslate nohighlight">\(Q\)</span> is called the <em>consequent</em>. The proposition <span class="math notranslate nohighlight">\(P\to Q\)</span> is called an <em>implication</em>
or a <em>conditional</em>.</p>
<div class="section" id="implication-elimination">
<span id="sec-imp-elim"></span><h3><span class="section-number">1.5.1. </span>Implication elimination<a class="headerlink" href="#implication-elimination" title="Permalink to this headline">&#182;</a></h3>
<div class="proof proof-type-mathsrule" id="id18">

    <div class="proof-title">
        <span class="proof-type">Rule 1.10</span>
        
            <span class="proof-title-name">(Implication elimination, forward)</span>
        
    </div><div class="proof-content">
<p>Given <span class="math notranslate nohighlight">\(h_1 : P \to Q\)</span> and <span class="math notranslate nohighlight">\(h_2 : P\)</span>, we have a proof of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
</div></div><div class="proof proof-type-mathsrule" id="id19">

    <div class="proof-title">
        <span class="proof-type">Rule 1.11</span>
        
            <span class="proof-title-name">(Implication elimination, backward)</span>
        
    </div><div class="proof-content">
<p>Given <span class="math notranslate nohighlight">\(h_1 : P \to Q\)</span>, to prove <span class="math notranslate nohighlight">\(Q\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(P\)</span>.</p>
</div></div><p>Here&#8217;s an example application of implication elimination.</p>
<div class="proof proof-type-example" id="id20">
<span id="example-imp-trans1"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.12</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h_1 : P \to Q\)</span>,
<span class="math notranslate nohighlight">\(h_2 : Q \to R\)</span> and <span class="math notranslate nohighlight">\(h_3 : P\)</span>, we have a proof of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</div></div><p>We&#8217;ll give two proofs of this. One using forward reasoning and one with backward reasoning.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Forward proof)</span>
        
    </div><div class="proof-content">
<p>By implication elimination on <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_3\)</span>, we have <span class="math notranslate nohighlight">\(h_4 : Q\)</span>.
We show <span class="math notranslate nohighlight">\(R\)</span> by implication elimination on <span class="math notranslate nohighlight">\(h_2\)</span> and <span class="math notranslate nohighlight">\(h_4\)</span>.</p>
</div></div><p>In Lean, the proof of <code class="docutils literal notranslate"><span class="pre">q</span></code> from <code class="docutils literal notranslate"><span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">h&#8322;</span> <span class="pre">:</span> <span class="pre">p</span></code> is simply denoted <code class="docutils literal notranslate"><span class="pre">h&#8321;</span> <span class="pre">h&#8322;</span></code>. The
Lean translation of the foward proof of <a class="reference internal" href="#example-imp-trans1"><span class="std std-numref">Example 1.12</span></a> is given below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20p%20%E2%86%92%20q)%20(h%E2%82%82%20%3A%20q%20%E2%86%92%20r)%20(h%E2%82%83%20%3A%20p)%20%3A%20r%20%3A%3D%0Abegin%0A%20%20have%20h%E2%82%84%20%3A%20q%2C%20from%20h%E2%82%81%20h%E2%82%83%2C%20--%20We%20have%20%60h%E2%82%84%20%3A%20q%60%2C%20by%20implication%20elimination%20on%20%60h%E2%82%81%60%20and%20%20%60h%E2%82%83%60.%0A%20%20show%20r%2C%20from%20h%E2%82%82%20h%E2%82%84%20%20%20%20%20%20%20--%20We%20show%20%60r%60%20by%20implication%20elimination%20on%20%60h%E2%82%82%60%20and%20%60h%E2%82%84%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_585.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#8324;</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span> <span class="n">h&#8323;</span><span class="o">,</span> <span class="c1">-- We have `h&#8324; : q`, by implication elimination on `h&#8321;` and  `h&#8323;`.</span>
  <span class="k">show</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8322;</span> <span class="n">h&#8324;</span>       <span class="c1">-- We show `r` by implication elimination on `h&#8322;` and `h&#8324;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Another approach it to dispose of <span class="math notranslate nohighlight">\(h_4\)</span> entirely. This is harder to read, but quicker to write.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Short forward proof)</span>
        
    </div><div class="proof-content">
<p><span class="math notranslate nohighlight">\(R\)</span> follows by implication elimination on <span class="math notranslate nohighlight">\(h_2\)</span> and the result of implication
elimination on <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_3\)</span>.</p>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20p%20%E2%86%92%20q)%20(h%E2%82%82%20%3A%20q%20%E2%86%92%20r)%20(h%E2%82%83%20%3A%20p)%20%3A%20r%20%3A%3D%0Abegin%0A%20%20show%20r%2C%20from%20h%E2%82%82%20(h%E2%82%81%20h%E2%82%83)%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_603.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">show</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8322;</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="n">h&#8323;</span><span class="o">)</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The next proof uses one backward application and one forward application of implication elimination.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Backward proof)</span>
        
    </div><div class="proof-content">
<p>To prove <span class="math notranslate nohighlight">\(R\)</span>, it suffices, by implication elimination on <span class="math notranslate nohighlight">\(h_2\)</span> to prove <span class="math notranslate nohighlight">\(Q\)</span>.
We show <span class="math notranslate nohighlight">\(Q\)</span> by implication elimination on <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_3\)</span>.</p>
</div></div><p>In Lean, given <code class="docutils literal notranslate"><span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> and a goal to prove <code class="docutils literal notranslate"><span class="pre">q</span></code>, we transform the goal into one of proving
<code class="docutils literal notranslate"><span class="pre">p</span></code> using <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">h&#8321;</span></code>. We use this to translate the above backward proof of
<a class="reference internal" href="#example-imp-trans1"><span class="std std-numref">Example 1.12</span></a>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20p%20%E2%86%92%20q)%20(h%E2%82%82%20%3A%20q%20%E2%86%92%20r)%20(h%E2%82%83%20%3A%20p)%20%3A%20r%20%3A%3D%0Abegin%0A%20%20apply%20h%E2%82%82%2C%20%20%20%20%20%20%20%20%20%20--%20By%20implication%20elimination%20on%20%60h%E2%82%82%60%2C%20it%20suffices%20to%20prove%20%60q%60.%0A%20%20show%20q%2C%20from%20h%E2%82%81%20h%E2%82%83%20--%20We%20show%20%60q%60%20by%20implication%20elimination%20on%20%60h%E2%82%81%60%20and%20%60h%E2%82%83%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_624.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">h&#8322;</span><span class="o">,</span>          <span class="c1">-- By implication elimination on `h&#8322;`, it suffices to prove `q`.</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span> <span class="n">h&#8323;</span> <span class="c1">-- We show `q` by implication elimination on `h&#8321;` and `h&#8323;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>If desired, we could give an entirely backward proof, finishing with reiteration.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20p%20%E2%86%92%20q)%20(h%E2%82%82%20%3A%20q%20%E2%86%92%20r)%20(h%E2%82%83%20%3A%20p)%20%3A%20r%20%3A%3D%0Abegin%0A%20%20apply%20h%E2%82%82%2C%20--%20By%20implication%20elimination%20on%20%60h%E2%82%82%60%2C%20it%20suffices%20to%20prove%20%60q%60.%0A%20%20apply%20h%E2%82%81%2C%20--%20By%20implication%20elimination%20on%20%60h%E2%82%81%60%2C%20it%20suffices%20to%20prove%20%60p%60.%0A%20%20exact%20h%E2%82%83%2C%20--%20This%20follows%20by%20reiteration%20on%20%60h%E2%82%83%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_637.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="c1">-- By implication elimination on `h&#8322;`, it suffices to prove `q`.</span>
  <span class="n">apply</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="c1">-- By implication elimination on `h&#8321;`, it suffices to prove `p`.</span>
  <span class="n">exact</span> <span class="n">h&#8323;</span><span class="o">,</span> <span class="c1">-- This follows by reiteration on `h&#8323;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Here&#8217;s an exercise in which the first line of the proof uses backward implication elimination.
You&#8217;ll also have to use conjunction introduction.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20r)%20(h%E2%82%82%20%3A%20p)%20(h%E2%82%83%20%3A%20q)%20%3A%20r%20%3A%3D%0Abegin%0A%20%20apply%20h%E2%82%81%2C%20--%20By%20implication%20elimination%20on%20%60h%E2%82%81%60%2C%20it%20suffices%20to%20prove%20%60p%20%E2%88%A7%20q%60.%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_652.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="c1">-- By implication elimination on `h&#8321;`, it suffices to prove `p &#8743; q`.</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>To really test your understanding of implication elimination, see if you can do the following
exercise.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20a%20b%20c%20d%20e%20f%20%3A%20Prop%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20d%20%E2%86%92%20a)%20(h%E2%82%82%20%3A%20f%20%E2%86%92%20b)%20(h%E2%82%83%20%3A%20e%20%E2%86%92%20c)%20(h%E2%82%84%20%3A%20e%20%E2%86%92%20a)%0A%20%20%20%20%20%20%20%20(h%E2%82%85%20%3A%20d%20%E2%86%92%20e)%20(h%E2%82%86%20%3A%20b%20%E2%86%92%20e)%20(h%E2%82%87%20%3A%20c)%20(h%E2%82%88%20%3A%20f)%20%3A%20a%20%3A%3D%0Abegin%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_666.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">&#8594;</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">f</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">&#8594;</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8324;</span> <span class="o">:</span> <span class="n">e</span> <span class="bp">&#8594;</span> <span class="n">a</span><span class="o">)</span>
        <span class="o">(</span><span class="n">h&#8325;</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">&#8594;</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8326;</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8327;</span> <span class="o">:</span> <span class="n">c</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8328;</span> <span class="o">:</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="implication-introduction">
<span id="sec-imp-intro"></span><h3><span class="section-number">1.5.2. </span>Implication introduction<a class="headerlink" href="#implication-introduction" title="Permalink to this headline">&#182;</a></h3>
<p>Implication introduction is one of the most important rules of inference. It is the only rule, in
propositional logic, that permits us to derive a goal on <em>no premises</em>. Due to this, impliciation
introduction only has a backward form.</p>
<div class="proof proof-type-mathsrule" id="id21">

    <div class="proof-title">
        <span class="proof-type">Rule 1.13</span>
        
            <span class="proof-title-name">(Implication introduction)</span>
        
    </div><div class="proof-content">
<p>To prove <span class="math notranslate nohighlight">\(P \to Q\)</span> is to assume <span class="math notranslate nohighlight">\(h : P\)</span> and derive <span class="math notranslate nohighlight">\(Q\)</span>.</p>
</div></div><div class="proof proof-type-example" id="id22">
<span id="example-imp-intro"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.14</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(Q \to (P \to Q)\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>By implication introduction, it suffices to assume <span class="math notranslate nohighlight">\(h_1 : Q\)</span> and deduce <span class="math notranslate nohighlight">\(P \to Q\)</span>.</p></li>
<li><p>To show <span class="math notranslate nohighlight">\(P \to Q\)</span>, it suffices, by implication introduction, to assume <span class="math notranslate nohighlight">\(h_2 : P\)</span> and
derive <span class="math notranslate nohighlight">\(Q\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(Q\)</span> by reiteration on <span class="math notranslate nohighlight">\(h_1\)</span>.</p></li>
</ul>
</div></div><p>In Lean, to prove <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code>, we begin with the <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactic to admit the assumption of the
antecedent <code class="docutils literal notranslate"><span class="pre">p</span></code> into the context and to change the goal to that of proving <code class="docutils literal notranslate"><span class="pre">q</span></code>. For example,
if the initial goal is to prove <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code>, then <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">h</span></code> adds <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span></code> into the context and
changes the goal to that of proving <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>Here&#8217;s a Lean proof of the theorem above.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20%3A%20q%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%0Abegin%0A%20%20intro%20h%E2%82%81%2C%20%20%20%20%20%20%20%20--%20Assume%20%60h%E2%82%81%20%3A%20q%60.%20It%20suffices%20to%20prove%20%60p%20%E2%86%92%20q%60.%0A%20%20intro%20h%E2%82%82%2C%20%20%20%20%20%20%20%20--%20Assume%20%60h%E2%82%82%20%3A%20p%60.%20It%20suffices%20to%20prove%20%60q%60.%0A%20%20show%20q%2C%20from%20h%E2%82%81%2C%20--%20We%20show%20%60q%60%20by%20reiteration%20on%20%60h%E2%82%81%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_712.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h&#8321;</span><span class="o">,</span>        <span class="c1">-- Assume `h&#8321; : q`. It suffices to prove `p &#8594; q`.</span>
  <span class="n">intro</span> <span class="n">h&#8322;</span><span class="o">,</span>        <span class="c1">-- Assume `h&#8322; : p`. It suffices to prove `q`.</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="c1">-- We show `q` by reiteration on `h&#8321;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>To make explicit what is being assumed, you may instead use the <code class="docutils literal notranslate"><span class="pre">assume</span></code> tactic. Below,
<code class="docutils literal notranslate"><span class="pre">assume</span> <span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">q</span></code> has an identical effect to <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">h&#8321;</span></code> above. The only difference is that
<code class="docutils literal notranslate"><span class="pre">assume</span></code> explicitly asserts that <code class="docutils literal notranslate"><span class="pre">h&#8321;</span></code> is an assumption of <code class="docutils literal notranslate"><span class="pre">q</span></code>. This aids the human reader.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Aexample%20%3A%20q%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20q%2C%20%20%20--%20Assume%20%60h%E2%82%81%20%3A%20q%60.%20It%20suffices%20to%20prove%20%60p%20%E2%86%92%20q%60.%0A%20%20assume%20h%E2%82%82%20%3A%20p%2C%20%20%20--%20Assume%20%60h%E2%82%82%20%3A%20p%60.%20It%20suffices%20to%20prove%20%60q%60.%0A%20%20show%20q%2C%20from%20h%E2%82%81%2C%20--%20We%20show%20%60q%60%20by%20reiteration%20on%20%60h%E2%82%81%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_728.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>   <span class="c1">-- Assume `h&#8321; : q`. It suffices to prove `p &#8594; q`.</span>
  <span class="k">assume</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>   <span class="c1">-- Assume `h&#8322; : p`. It suffices to prove `q`.</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="c1">-- We show `q` by reiteration on `h&#8321;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The next result requires reiteration.</p>
<div class="proof proof-type-theorem" id="id23">
<span id="thm-reflexivity-imp"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.15</span>
        
            <span class="proof-title-name">(Reflexivity of implication)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> be a proposition. Then <span class="math notranslate nohighlight">\(P \to P\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Assume <span class="math notranslate nohighlight">\(h : P\)</span>. By implication introduction, it suffices to prove <span class="math notranslate nohighlight">\(P\)</span>. The result
follows by reiteration on <span class="math notranslate nohighlight">\(h\)</span>.</p>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20%3A%20Prop%7D%0Anamespace%20hidden%0A--%20BEGIN%0Atheorem%20id%20%3A%20p%20%E2%86%92%20p%20%3A%3D%0Abegin%0A%20%20assume%20h%20%3A%20p%2C%20%20%20--%20Assume%20%60h%20%3A%20p%60.%20It%20suffices%20to%20prove%20%60p%60.%0A%20%20show%20p%2C%20from%20h%2C%20--%20We%20show%20%60p%60%20by%20reiteration%20on%20%60h%60.%0Aend%0A--%20END%0Aend%20hidden" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_753.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">id</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>   <span class="c1">-- Assume `h : p`. It suffices to prove `p`.</span>
  <span class="k">show</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span><span class="o">,</span> <span class="c1">-- We show `p` by reiteration on `h`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><div class="proof proof-type-theorem" id="id24">
<span id="thm-and-comm2"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.16</span>
        
            <span class="proof-title-name">(Commutativity of conjunction (II))</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(P \land Q \to Q \land P\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>By implication introduction, it suffices to assume <span class="math notranslate nohighlight">\(h : P \land Q\)</span> and deduce
<span class="math notranslate nohighlight">\(Q \land P\)</span>.</p></li>
<li><p>To show <span class="math notranslate nohighlight">\(P \land Q\)</span>, it suffices, by conjunction introduction, to prove both 1. <span class="math notranslate nohighlight">\(Q\)</span>
and 2. <span class="math notranslate nohighlight">\(P\)</span>.</p>
<ol class="arabic simple">
<li><p>We show <span class="math notranslate nohighlight">\(Q\)</span> from right conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(P\)</span> from left conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
</ol>
</li>
</ul>
</div></div><p>Here is the same proof in Lean. Note that we use <code class="docutils literal notranslate"><span class="pre">theorem</span></code> below instead of <code class="docutils literal notranslate"><span class="pre">example</span></code>. This
produces a named result. Here, we call the result <code class="docutils literal notranslate"><span class="pre">and_of_and</span></code>. We&#8217;ll discuss theorems further
in <a class="reference internal" href="#sec-theorems"><span class="std std-numref">Section 1.6</span></a>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20and_of_and%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%20%3A%20p%20%E2%88%A7%20q%60.%20It%20suffices%20to%20prove%20%60q%20%E2%88%A7%20p%60.%0A%20%20split%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20%60%E2%88%A7%60%20intro.%2C%20it%20suffices%20to%20prove%20both%20%60q%60%20and%20%60p%60.%0A%20%20%7B%20show%20q%2C%20from%20h.right%2C%20%7D%2C%20--%20We%20show%20%60q%60%20from%20right%20%60%E2%88%A7%60%20elimination%20on%20%60h%60.%0A%20%20%7B%20show%20p%2C%20from%20h.left%2C%20%7D%2C%20%20--%20We%20show%20%60p%60%20from%20left%20%60%E2%88%A7%60%20elimination%20on%20%60h%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_788.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_of_and</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>                   <span class="c1">-- Assume `h : p &#8743; q`. It suffices to prove `q &#8743; p`.</span>
  <span class="n">split</span><span class="o">,</span>                     <span class="c1">-- By `&#8743;` intro., it suffices to prove both `q` and `p`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- We show `q` from right `&#8743;` elimination on `h`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span> <span class="o">},</span>  <span class="c1">-- We show `p` from left `&#8743;` elimination on `h`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The proof above uses backward conjunction introduction to prove <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code>. We can alternatively use
forward conjunction introduction. Additionally, I use <code class="docutils literal notranslate"><span class="pre">assume</span></code> below instead of <code class="docutils literal notranslate"><span class="pre">intro</span></code> to
improve readability.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20and_of_and%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20assume%20h%20%3A%20p%20%E2%88%A7%20q%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%20%3A%20p%20%E2%88%A7%20q%60.%20It%20suffices%20to%20prove%20%60q%20%E2%88%A7%20p%60.%0A%20%20have%20h%E2%82%82%20%3A%20q%2C%20from%20h.right%2C%20%20%20%20%20%20%20%20--%20We%20have%20%60h%E2%82%82%20%3A%20q%60%20by%20right%20conjunction%20elimination%20on%20%60h%60.%0A%20%20have%20h%E2%82%83%20%3A%20p%2C%20from%20h.left%2C%20%20%20%20%20%20%20%20%20--%20We%20have%20%60h%E2%82%83%20%3A%20p%60%20by%20left%20conjunction%20elimination%20on%20%60h%60.%0A%20%20show%20q%20%E2%88%A7%20p%2C%20from%20and.intro%20h%E2%82%82%20h%E2%82%83%2C%20--%20We%20show%20%60q%20%E2%88%A7%20p%60%20from%20conjunction%20introduction%20on%20%60h%E2%82%82%60%20and%20%60h%E2%82%83%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_805.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_of_and</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">,</span>                 <span class="c1">-- Assume `h : p &#8743; q`. It suffices to prove `q &#8743; p`.</span>
  <span class="k">have</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.right</span><span class="o">,</span>        <span class="c1">-- We have `h&#8322; : q` by right conjunction elimination on `h`.</span>
  <span class="k">have</span> <span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.left</span><span class="o">,</span>         <span class="c1">-- We have `h&#8323; : p` by left conjunction elimination on `h`.</span>
  <span class="k">show</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">and.intro</span> <span class="n">h&#8322;</span> <span class="n">h&#8323;</span><span class="o">,</span> <span class="c1">-- We show `q &#8743; p` from conjunction introduction on `h&#8322;` and `h&#8323;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>If you&#8217;ve been paying close attention, you&#8217;ll note that the proofs above virtually the same as
our proofs of <a class="reference internal" href="#example-and-comm1"><span class="std std-numref">Example 1.5</span></a>, the result that given <span class="math notranslate nohighlight">\(h : P \land Q\)</span>,
we have a proof of <span class="math notranslate nohighlight">\(Q \land P\)</span>. The only difference is the addition of <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">h</span></code> as the
first line of the Lean proof or &#8216;Assume <span class="math notranslate nohighlight">\(h : P \land Q\)</span>, it suffices to prove
<span class="math notranslate nohighlight">\(Q \land P\)</span>&#8217; as the first line of the mathematical proof.</p>
<p>In general, by enough applications of implication introduction, one can transform a result that
involves premises into a result with no premises.</p>
</div>
</div>
<div class="section" id="theorems">
<span id="sec-theorems"></span><h2><span class="section-number">1.6. </span>Theorems<a class="headerlink" href="#theorems" title="Permalink to this headline">&#182;</a></h2>
<div class="section" id="reusing-results">
<h3><span class="section-number">1.6.1. </span>Reusing results<a class="headerlink" href="#reusing-results" title="Permalink to this headline">&#182;</a></h3>
<p>One great thing about mathematics is that we don&#8217;t constantly have to reinvent the wheel. Once
a result is proved, we can use it to prove other results.</p>
<p>A <em>theorem</em> is a named result. In the previous section, we have a mathematical theorem we can refer
to by number as <a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a> or by name as the <a class="reference internal" href="#thm-and-comm2"><span class="std std-ref">Commutativity of conjunction (II)</span></a> theorem.
We called the corresponding Lean theorem <code class="docutils literal notranslate"><span class="pre">and_of_and</span></code>.</p>
<p>Think about how you might prove the following.</p>
<div class="proof proof-type-example" id="id25">
<span id="example-and-comm-funny"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.17</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be propositions. Then
<span class="math notranslate nohighlight">\((A \to B) \land (B\land A) \to (B\land A) \land (A\to B)\)</span>.</p>
</div></div><p>We can get our hands dirty and leap straight into a proof as follows.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(From the rules of inference)</span>
        
    </div><div class="proof-content">
<p>Assume <span class="math notranslate nohighlight">\(h : (A\to B)\land(B\land A)\)</span>. It suffices to prove <span class="math notranslate nohighlight">\((B\land A)\land(A\to B)\)</span>.
By conjunction introduction, it suffices to prove both 1. <span class="math notranslate nohighlight">\(B\land A\)</span> and 2. <span class="math notranslate nohighlight">\(A\to B\)</span>.</p>
<ol class="arabic simple">
<li><p>This follows from right conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
<li><p>This follows from left conjunction elimination on <span class="math notranslate nohighlight">\(h\)</span>.</p></li>
</ol>
</div></div><p>But this proof is virtually identical to our proof of <a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a>.
Indeed, the <em>statement</em> of <a class="reference internal" href="#example-and-comm-funny"><span class="std std-numref">Example 1.17</span></a> is essentially that of
<a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a>, only with <span class="math notranslate nohighlight">\(A\to B\)</span> in place of <span class="math notranslate nohighlight">\(P\)</span> and
<span class="math notranslate nohighlight">\(B\land A\)</span> in place of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Indeed, one should think of <a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a> as stating that
<span class="math notranslate nohighlight">\(P \land Q \to Q \land P\)</span> <em>for all</em> propositions <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>. We will develop the
notion of &#8216;for all&#8217; further in <a class="reference internal" href="pred_logic.html#sec-pred-logic"><span class="std std-numref">Section 3</span></a>.</p>
<p>For the moment, we should think of the variables <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> that appear in the
statement of <a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a> as being <em>placeholders</em>, <em>inputs</em> or <em>parameters</em>
that we can replace with any given terms, called <em>arguments</em>.</p>
<p>For example, taking <span class="math notranslate nohighlight">\(A\to B\)</span> and <span class="math notranslate nohighlight">\(B\land A\)</span> as arguments to the theorem gives a
one-line proof of <a class="reference internal" href="#example-and-comm-funny"><span class="std std-numref">Example 1.17</span></a>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Using a previously proved theorem with explicit arguments)</span>
        
    </div><div class="proof-content">
<p>The result follows by <a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a> applied to <span class="math notranslate nohighlight">\(A \to B\)</span> and
<span class="math notranslate nohighlight">\(B \land A\)</span>.</p>
</div></div><p>A Lean proof of the result above uses the theorem <code class="docutils literal notranslate"><span class="pre">and_of_and</span></code>, our Lean version of
<a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a>. We repeat (a more concise version of) this theorem below along
with our proof of the new result.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20a%20b%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20and_of_and%20(p%20q%20%3A%20Prop)%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%0A%20%20exact%20and.intro%20(h.right)%20(h.left)%0Aend%0A%0Aexample%20%3A%20(a%20%E2%86%92%20b)%20%E2%88%A7%20(b%20%E2%88%A7%20a)%20%E2%86%92%20(b%20%E2%88%A7%20a)%20%E2%88%A7%20(a%20%E2%86%92%20b)%20%3A%3D%0Aby%20exact%20and_of_and%20(a%20%E2%86%92%20b)%20(b%20%E2%88%A7%20a)%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_889.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_of_and</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.intro</span> <span class="o">(</span><span class="n">h.right</span><span class="o">)</span> <span class="o">(</span><span class="n">h.left</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">exact</span> <span class="n">and_of_and</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span>
</pre></div>
</div>
</div></div>
<div class="section" id="placeholders">
<h3><span class="section-number">1.6.2. </span>Placeholders<a class="headerlink" href="#placeholders" title="Permalink to this headline">&#182;</a></h3>
<p>Often, it isn&#8217;t necessary to present the arguments explicitly. There are two alternatives. One is
the use of the Lean placeholder, denoted by an underscore character, <code class="docutils literal notranslate"><span class="pre">_</span></code>. Whenever Lean
encounters an <code class="docutils literal notranslate"><span class="pre">_</span></code>, it tries to <em>infer</em> an appropriate term. In the example below, Lean will infer
that the first and second underscores should be replaced with <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8594;</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">&#8743;</span> <span class="pre">a</span></code> respectively.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20a%20b%20%3A%20Prop%0A%0Atheorem%20and_of_and%20(p%20q%20%3A%20Prop)%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%0A%20%20exact%20and.intro%20(h.right)%20(h.left)%0Aend%0A--%20BEGIN%0Aexample%20%3A%20(a%20%E2%86%92%20b)%20%E2%88%A7%20(b%20%E2%88%A7%20a)%20%E2%86%92%20(b%20%E2%88%A7%20a)%20%E2%88%A7%20(a%20%E2%86%92%20b)%20%3A%3D%0Aby%20exact%20and_of_and%20_%20_%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_912.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">exact</span> <span class="n">and_of_and</span> <span class="n">_</span> <span class="n">_</span>
</pre></div>
</div>
</div></div>
<div class="section" id="implicit-arguments">
<h3><span class="section-number">1.6.3. </span>Implicit arguments<a class="headerlink" href="#implicit-arguments" title="Permalink to this headline">&#182;</a></h3>
<p>In situations like the above, it is evident that the arguments <em>must be</em> <span class="math notranslate nohighlight">\(A\to B\)</span> and
<span class="math notranslate nohighlight">\(B\land A\)</span> because those are the arguments that match
the form of the theorem with the form of the goal. It is typical in such situations not to
state the arguments explicity in a mathematical proof but to leave them implicit.</p>
<p>Here&#8217;s our shortened proof of <a class="reference internal" href="#example-and-comm-funny"><span class="std std-numref">Example 1.17</span></a>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Using a previously proved theorem with implicit arguments)</span>
        
    </div><div class="proof-content">
<p>The result follows by <a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a>.</p>
</div></div><p>To enable the use of implicit arguments in Lean, we need to use a special syntax when stating our
theorem. In the statement of theorem <code class="docutils literal notranslate"><span class="pre">and_of_and_v2</span></code> below, we enclose the variable declarations
in braces <code class="docutils literal notranslate"><span class="pre">{p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop}</span></code> in contrast to the parentheses <code class="docutils literal notranslate"><span class="pre">(p</span> <span class="pre">q</span> <span class="pre">:</span> <span class="pre">Prop)</span></code> in the earlier version.</p>
<p>In application of the theorem, we write merely <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">and_of_and_v2</span></code> in place of our
previous <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">and_of_and</span> <span class="pre">(a</span> <span class="pre">&#8594;</span> <span class="pre">b)</span> <span class="pre">(b</span> <span class="pre">&#8743;</span> <span class="pre">a)</span></code>. In the new proof, the arguments <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8594;</span> <span class="pre">b</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">&#8743;</span> <span class="pre">a</span></code> to the theorem <code class="docutils literal notranslate"><span class="pre">and_of_and_v2</span></code> are implicit.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20a%20b%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20and_of_and_v2%20%7Bp%20q%20%3A%20Prop%7D%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20assume%20h%2C%0A%20%20exact%20and.intro%20(h.right)%20(h.left)%0Aend%0A%0Aexample%20%3A%20(a%20%E2%86%92%20b)%20%E2%88%A7%20(b%20%E2%88%A7%20a)%20%E2%86%92%20(b%20%E2%88%A7%20a)%20%E2%88%A7%20(a%20%E2%86%92%20b)%20%3A%3D%0Aby%20exact%20and_of_and_v2%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_951.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_of_and_v2</span> <span class="o">{</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.intro</span> <span class="o">(</span><span class="n">h.right</span><span class="o">)</span> <span class="o">(</span><span class="n">h.left</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">exact</span> <span class="n">and_of_and_v2</span>
</pre></div>
</div>
</div></div>
<div class="section" id="using-theorems-with-the-apply-tactic">
<h3><span class="section-number">1.6.4. </span>Using theorems with the <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic<a class="headerlink" href="#using-theorems-with-the-apply-tactic" title="Permalink to this headline">&#182;</a></h3>
<p>Another way to use a theorem is via the <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic. In <a class="reference internal" href="#sec-imp-elim"><span class="std std-numref">Section 1.5.1</span></a>,
we used <code class="docutils literal notranslate"><span class="pre">apply</span></code> with terms of type <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> when the goal is of type <code class="docutils literal notranslate"><span class="pre">q</span></code>. In that case, the
apply tactic replaces the goal with one of proving <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>More generally, the <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic can be used on a term <code class="docutils literal notranslate"><span class="pre">h</span></code> whenever the type of the goal
matches the &#8216;conclusion&#8217; of the type of <code class="docutils literal notranslate"><span class="pre">h</span></code>. The <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic replaces the goal with as many
subgoals as there are &#8216;premises&#8217; of <code class="docutils literal notranslate"><span class="pre">h</span></code> and tries to close the goal by inference.</p>
<p>Let&#8217;s see how <code class="docutils literal notranslate"><span class="pre">apply</span></code> works when used with the theorem <code class="docutils literal notranslate"><span class="pre">and_or_and</span></code> which states, for all
propositions <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> that <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code>. The goal is to prove <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">&#8743;</span> <span class="pre">a)</span> <span class="pre">&#8743;</span> <span class="pre">(a</span> <span class="pre">&#8594;</span> <span class="pre">b)</span></code>.
The <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic matches the goal with the conclusion <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8743;</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">q</span> <span class="pre">&#8743;</span> <span class="pre">p</span></code> and introduces
new goals for <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>. Lean automatically infers that
<code class="docutils literal notranslate"><span class="pre">p</span></code> should be replaced with <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">&#8743;</span> <span class="pre">a</span></code> and that <code class="docutils literal notranslate"><span class="pre">q</span></code> should be replaced with <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8594;</span> <span class="pre">b</span></code>, closing
these new goals.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20a%20b%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20and_of_and%20(p%20q%20%3A%20Prop)%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%0A%20%20exact%20and.intro%20(h.right)%20(h.left)%0Aend%0A%0Aexample%20(a%20b%20%3A%20Prop)%20%3A%20(a%20%E2%86%92%20b)%20%E2%88%A7%20(b%20%E2%88%A7%20a)%20%E2%86%92%20(b%20%E2%88%A7%20a)%20%E2%88%A7%20(a%20%E2%86%92%20b)%20%3A%3D%0Aby%20apply%20and_of_and%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_983.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_of_and</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">and.intro</span> <span class="o">(</span><span class="n">h.right</span><span class="o">)</span> <span class="o">(</span><span class="n">h.left</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">a</span> <span class="bp">&#8594;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">apply</span> <span class="n">and_of_and</span>
</pre></div>
</div>
</div><p>In more interesting examples, Lean cannot automatically close the new goals introduced by <code class="docutils literal notranslate"><span class="pre">apply</span></code>.</p>
<p>We begin with a juicy theorem whose proof is a good exercise in the rules of inference for
implication.</p>
<div class="proof proof-type-theorem" id="id26">
<span id="thm-imp-trans1"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.18</span>
        
            <span class="proof-title-name">(Transitivity of implication)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> be propositions.
Then <span class="math notranslate nohighlight">\((P\to Q)\to((Q\to R)\to (P \to R))\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Assume <span class="math notranslate nohighlight">\(h_1 : P\to Q\)</span>. By implication introduction, it suffices to prove
<span class="math notranslate nohighlight">\((Q\to R)\to (P \to R)\)</span>.</p>
<p>Assume <span class="math notranslate nohighlight">\(h_2 : Q \to R\)</span>. By implication introduction, it suffices to prove <span class="math notranslate nohighlight">\(P \to R\)</span>.</p>
<p>Asssume <span class="math notranslate nohighlight">\(h_3 : P\)</span>. By implication introduction, it suffices to prove <span class="math notranslate nohighlight">\(R\)</span>.</p>
<p>By implication eliminiation on <span class="math notranslate nohighlight">\(h_2\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>We show <span class="math notranslate nohighlight">\(Q\)</span> by implication elimination on <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_3\)</span>.</p>
</div></div><p>The proof has a direct translation into Lean.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20imp_trans1%20%3A%20(p%20%E2%86%92%20q)%20%E2%86%92%20(q%20%E2%86%92%20r)%20%E2%86%92%20(p%20%E2%86%92%20r)%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20p%20%E2%86%92%20q%2C%20%20--%20Assume%20%60h%E2%82%81%20%3A%20p%20%E2%86%92%20q%60.%20By%20implication%20introduction%2C%20it%20suffices%20to%20prove%20%60(q%20%E2%86%92%20r)%20%E2%86%92%20(p%20%E2%86%92%20r)%60.%0A%20%20assume%20h%E2%82%82%20%3A%20q%20%E2%86%92%20r%2C%20%20--%20Assume%20%60h%E2%82%82%20%3A%20q%20%E2%86%92%20r%60.%20By%20implication%20introduction%2C%20it%20suffices%20to%20prove%20%60p%20%E2%86%92%20r%60.%0A%20%20assume%20h%E2%82%83%20%3A%20p%2C%20%20%20%20%20%20--%20Assume%20%60h%E2%82%83%20%3A%20p%60.%20It%20suffices%20to%20prove%20%60r%60.%0A%20%20apply%20h%E2%82%82%2C%20%20%20%20%20%20%20%20%20%20%20--%20By%20implication%20elimination%20on%20%60h%E2%82%82%60%2C%20it%20suffices%20to%20prove%20%60q%60.%0A%20%20show%20q%2C%20from%20h%E2%82%81%20h%E2%82%83%2C%20--%20We%20show%20%60q%60%20by%20implication%20elimination%20on%20%60h%E2%82%81%60%20and%20%60h%E2%82%83%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1024.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">imp_trans1</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">,</span>  <span class="c1">-- Assume `h&#8321; : p &#8594; q`. By implication introduction, it suffices to prove `(q &#8594; r) &#8594; (p &#8594; r)`.</span>
  <span class="k">assume</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">,</span>  <span class="c1">-- Assume `h&#8322; : q &#8594; r`. By implication introduction, it suffices to prove `p &#8594; r`.</span>
  <span class="k">assume</span> <span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>      <span class="c1">-- Assume `h&#8323; : p`. It suffices to prove `r`.</span>
  <span class="n">apply</span> <span class="n">h&#8322;</span><span class="o">,</span>           <span class="c1">-- By implication elimination on `h&#8322;`, it suffices to prove `q`.</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span> <span class="n">h&#8323;</span><span class="o">,</span> <span class="c1">-- We show `q` by implication elimination on `h&#8321;` and `h&#8323;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>There are several ways to think about <a class="reference internal" href="#thm-imp-trans1"><span class="std std-numref">Theorem 1.18</span></a>.</p>
<p>First, it can be seen as a statement with propositional parameters <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>,
and <span class="math notranslate nohighlight">\(R\)</span> that can be replaced with arguments, say <span class="math notranslate nohighlight">\(S\)</span>, <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(U\)</span> to
give a proof of</p>
<div class="math notranslate nohighlight">
\[(S \to T) \to ((T\to U)\to (S\to U)).\]</div>
<p>Second, we can develop this idea via the rules of inference for implication to &#8216;peel off&#8217; the antecedent
of the theorem and intepret it as stating that for given propositions <span class="math notranslate nohighlight">\(S\)</span>, <span class="math notranslate nohighlight">\(T\)</span>, and
<span class="math notranslate nohighlight">\(U\)</span> <em>and</em> given <span class="math notranslate nohighlight">\(h_1 : S \to T\)</span>, we have a proof of <span class="math notranslate nohighlight">\((T \to U) \to (S \to U)\)</span>.</p>
<p>Third, we can peel off the next implication. The theorem then states that given propositions
<span class="math notranslate nohighlight">\(S\)</span>, <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(U\)</span>, given <span class="math notranslate nohighlight">\(h_1 : S \to T\)</span> and <span class="math notranslate nohighlight">\(h_2 : T\to U\)</span>, we have
a proof of <span class="math notranslate nohighlight">\(S\to U\)</span>. There&#8217;s even a fourth option that I leave for the reader to
determine.</p>
<p>We use the third interpretation of the theorem in proving the result below.</p>
<div class="proof proof-type-example" id="id27">

    <div class="proof-title">
        <span class="proof-type">Example 1.19</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(S\)</span>, <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(U\)</span> be propositions. Given <span class="math notranslate nohighlight">\(k_1 : S \to T \land S\)</span> and
<span class="math notranslate nohighlight">\(k_2 : T \to U\)</span>, we have a proof of <span class="math notranslate nohighlight">\(S \to U\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Applying <a class="reference internal" href="#thm-imp-trans1"><span class="std std-numref">Theorem 1.18</span></a> (to propositions <span class="math notranslate nohighlight">\(S\)</span>, <span class="math notranslate nohighlight">\(T\land S\)</span>, and
<span class="math notranslate nohighlight">\(U\)</span>),
it suffices to prove <span class="math notranslate nohighlight">\(S \to T\land S\)</span> and <span class="math notranslate nohighlight">\(T\land S \to U\)</span>.</p>
<ol class="arabic simple">
<li><p>We show <span class="math notranslate nohighlight">\(S\to T\land S\)</span> by reiteration on <span class="math notranslate nohighlight">\(k_1\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(T\land S\to U\)</span> as follows. Assume <span class="math notranslate nohighlight">\(k_3 : T\land S\)</span>. By implication
introduction, it suffices to prove <span class="math notranslate nohighlight">\(U\)</span>.
We have <span class="math notranslate nohighlight">\(k_4 : T\)</span> by left conjunction elimination on <span class="math notranslate nohighlight">\(k_3\)</span>. The result follows by
implication elimination on <span class="math notranslate nohighlight">\(k_2\)</span> and <span class="math notranslate nohighlight">\(k_4\)</span>.</p></li>
</ol>
</div></div><p>This translates neatly into Lean via the <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20s%20t%20u%20%3A%20Prop%0A%0Atheorem%20imp_trans1%20%3A%20(p%20%E2%86%92%20q)%20%E2%86%92%20(q%20%E2%86%92%20r)%20%E2%86%92%20(p%20%E2%86%92%20r)%20%3A%3D%0A%CE%BB%20h%E2%82%81%20h%E2%82%82%20h%E2%82%83%2C%20h%E2%82%82%20(h%E2%82%81%20h%E2%82%83)%0A--%20BEGIN%0Aexample%20(k%E2%82%81%20%3A%20s%20%E2%86%92%20t%20%E2%88%A7%20s)%20(k%E2%82%82%20%3A%20t%20%E2%86%92%20u)%20%3A%20s%20%E2%86%92%20u%20%3A%3D%0Abegin%0A%20%20apply%20imp_trans1%2C%0A%20%20%7B%20show%20s%20%E2%86%92%20t%20%E2%88%A7%20s%2C%20from%20k%E2%82%81%2C%20%7D%2C%0A%20%20%7B%20show%20t%20%E2%88%A7%20s%20%E2%86%92%20u%2C%0A%20%20%20%20assume%20k%E2%82%83%20%3A%20t%20%E2%88%A7%20s%2C%0A%20%20%20%20have%20k%E2%82%84%20%3A%20t%2C%20from%20k%E2%82%83.left%2C%0A%20%20%20%20show%20u%2C%20from%20k%E2%82%82%20k%E2%82%84%2C%20%7D%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1080.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">k&#8321;</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">t</span> <span class="bp">&#8743;</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">k&#8322;</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">&#8594;</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">u</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">imp_trans1</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">t</span> <span class="bp">&#8743;</span> <span class="n">s</span><span class="o">,</span> <span class="k">from</span> <span class="n">k&#8321;</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">t</span> <span class="bp">&#8743;</span> <span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">u</span><span class="o">,</span>
    <span class="k">assume</span> <span class="n">k&#8323;</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">&#8743;</span> <span class="n">s</span><span class="o">,</span>
    <span class="k">have</span> <span class="n">k&#8324;</span> <span class="o">:</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">k&#8323;.left</span><span class="o">,</span>
    <span class="k">show</span> <span class="n">u</span><span class="o">,</span> <span class="k">from</span> <span class="n">k&#8322;</span> <span class="n">k&#8324;</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="exercises">
<h3><span class="section-number">1.6.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h3>
<p>Prove the following result, a variant (with no premises) of our previous result
<a class="reference internal" href="#example-and-assoc1-0"><span class="std std-numref">Example 1.6</span></a>.</p>
<div class="proof proof-type-theorem" id="id28">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.20</span>
        
            <span class="proof-title-name">(Associativity of conjunction)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> be propositions. Then
<span class="math notranslate nohighlight">\((P \land Q)\land R \to P\land(Q\land R)\)</span>.</p>
</div></div><p>Here&#8217;s a Lean template for the proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20and_assoc1%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%20%E2%86%92%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r)%20%3A%3D%0Abegin%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1111.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_assoc1</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">r</span> <span class="bp">&#8594;</span> <span class="n">p</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>As an exercise in applying theorems, prove the following, subject to the following restrictions.
Your proof must begin with implication introduction. It must end with reiteration.
All other steps must be applications of either the above theorem or our result on the commutativity
of conjunction, <a class="reference internal" href="#example-and-comm1"><span class="std std-numref">Theorem 1.5</span></a></p>
<div class="proof proof-type-theorem" id="id29">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.21</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(S\)</span>, <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(U\)</span> be propositions. Then
<span class="math notranslate nohighlight">\(S\land(T\land U) \to (S\land T)\land U\)</span>.</p>
</div></div><p>Here is a Lean template for the proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20s%20t%20u%20%3A%20Prop%0A%0Atheorem%20and_assoc1%20%3A%20(p%20%E2%88%A7%20q)%20%E2%88%A7%20r%20%E2%86%92%20p%20%E2%88%A7%20(q%20%E2%88%A7%20r)%20%3A%3D%0A%CE%BB%20h%2C%20%E2%9F%A8h.1.1%2C%20h.1.2%2C%20h.2%E2%9F%A9%0A%0Atheorem%20and_of_and%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0A%CE%BB%20h%2C%20%E2%9F%A8h.2%2C%20h.1%E2%9F%A9%0A--%20BEGIN%0Atheorem%20and_assoc2%20%3A%20s%20%E2%88%A7%20(t%20%E2%88%A7%20u)%20%E2%86%92%20(s%20%E2%88%A7%20t)%20%E2%88%A7%20u%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%0A%20%20sorry%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1134.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_assoc2</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="n">t</span> <span class="bp">&#8743;</span> <span class="n">u</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">s</span> <span class="bp">&#8743;</span> <span class="n">t</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">u</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="if-and-only-if">
<h2><span class="section-number">1.7. </span>If and only if<a class="headerlink" href="#if-and-only-if" title="Permalink to this headline">&#182;</a></h2>
<p>The biconditional connective <span class="math notranslate nohighlight">\(\leftrightarrow\)</span> is also called &#8216;if and only if&#8217; or &#8216;iff&#8217;.
The proposition <span class="math notranslate nohighlight">\(P \leftrightarrow Q\)</span> is read &#8216;<span class="math notranslate nohighlight">\(P\)</span> if and only if <span class="math notranslate nohighlight">\(Q\)</span>&#8217; or
&#8216;<span class="math notranslate nohighlight">\(P\)</span> is equivalent to <span class="math notranslate nohighlight">\(Q\)</span>&#8217;.</p>
<p>There are strong parallels between the rules of inference for iff and those for conjunction.</p>
<div class="proof proof-type-mathsrule" id="id30">

    <div class="proof-title">
        <span class="proof-type">Rule 1.22</span>
        
            <span class="proof-title-name">(If and only if elimination)</span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>(<em>Left iff elimination</em>) given <span class="math notranslate nohighlight">\(h : P \leftrightarrow Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P\to Q\)</span>.</p></li>
<li><p>(<em>Right iff elimination</em>) given <span class="math notranslate nohighlight">\(h : P \leftrightarrow Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(Q\to P\)</span>.</p></li>
</ul>
</div></div><p>In Lean, if <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code>, then <code class="docutils literal notranslate"><span class="pre">h.1</span></code> (alternatively <code class="docutils literal notranslate"><span class="pre">iff.elim_left</span> <span class="pre">h</span></code>) is a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code>.
Likewise, <code class="docutils literal notranslate"><span class="pre">h.2</span></code> (alternatively <code class="docutils literal notranslate"><span class="pre">iff.elim_right</span> <span class="pre">h</span></code>) is a proof of <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>.</p>
<div class="proof proof-type-mathsrule" id="id31">

    <div class="proof-title">
        <span class="proof-type">Rule 1.23</span>
        
            <span class="proof-title-name">(Iff introduction, forward)</span>
        
    </div><div class="proof-content">
<p>Given <span class="math notranslate nohighlight">\(h_1 : P \to Q\)</span> and <span class="math notranslate nohighlight">\(h_2 : Q\to P\)</span>, we have a proof of
<span class="math notranslate nohighlight">\(P\leftrightarrow Q\)</span>.</p>
</div></div><p>In Lean, given <code class="docutils literal notranslate"><span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">h&#8322;</span> <span class="pre">:</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">p</span></code>, the term <code class="docutils literal notranslate"><span class="pre">iff.intro</span> <span class="pre">h&#8321;</span> <span class="pre">h&#8322;</span></code> is
a proof of <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8596;</span> <span class="pre">q</span></code>. The same proof term can be denoted using the anonymous constructor notation
as <code class="docutils literal notranslate"><span class="pre">&#10216;h&#8321;,</span> <span class="pre">h&#8322;&#10217;</span></code>. Recall that <code class="docutils literal notranslate"><span class="pre">&#10216;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#10217;</span></code> are written as <code class="docutils literal notranslate"><span class="pre">\&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">\&gt;</span></code> respectively.</p>
<div class="proof proof-type-mathsrule" id="id32">

    <div class="proof-title">
        <span class="proof-type">Rule 1.24</span>
        
            <span class="proof-title-name">(Iff introduction, backward)</span>
        
    </div><div class="proof-content">
<p>To prove <span class="math notranslate nohighlight">\(P\leftrightarrow Q\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(P\to Q\)</span> and <span class="math notranslate nohighlight">\(Q\to P\)</span>.</p>
</div></div><p>We&#8217;ll use these rules of inference to prove our (almost) final form of commutativity of conjunction.
The proof below uses <a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a>, that if <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> are
propositions, then <span class="math notranslate nohighlight">\(P \land Q\to Q \land P\)</span>.</p>
<div class="proof proof-type-theorem" id="id33">
<span id="thm-and-comm3"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.25</span>
        
            <span class="proof-title-name">(Commutativity of conjunction (III))</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(R\)</span> and <span class="math notranslate nohighlight">\(S\)</span> be propositions. Then <span class="math notranslate nohighlight">\(R \land S \leftrightarrow S \land R\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By iff introduction, it suffices to prove 1. <span class="math notranslate nohighlight">\(R\land S\to S\land R\)</span> and
2. <span class="math notranslate nohighlight">\(S\land R\to R\land S\)</span>. We close both goals by <a class="reference internal" href="#thm-and-comm2"><span class="std std-numref">Theorem 1.16</span></a>.</p>
</div></div><p>In Lean, using one proof to close more than one goal is denoted by the <code class="docutils literal notranslate"><span class="pre">;</span></code> tactic combinator, as
used in the proof below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20s%20r%20%3A%20Prop%0Atheorem%20and_of_and%20%3A%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%20%3A%20p%20%E2%88%A7%20q%60.%20It%20suffices%20to%20prove%20%60q%20%E2%88%A7%20p%60.%0A%20%20split%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20%60%E2%88%A7%60%20intro.%2C%20it%20suffices%20to%20prove%20both%20%60q%60%20and%20%60p%60.%0A%20%20%7B%20show%20q%2C%20from%20h.right%2C%20%7D%2C%20--%20We%20show%20%60q%60%20from%20right%20%60%E2%88%A7%60%20elimination%20on%20%60h%60.%0A%20%20%7B%20show%20p%2C%20from%20h.left%2C%20%7D%2C%20%20--%20We%20show%20%60p%60%20from%20left%20%60%E2%88%A7%60%20elimination%20on%20%60h%60.%0Aend%0Anamespace%20hidden%0A--%20BEGIN%0Atheorem%20and_comm%20%3A%20r%20%E2%88%A7%20s%20%E2%86%94%20s%20%E2%88%A7%20r%20%3A%3D%0Abegin%0A%20%20split%3B%0A%20%20apply%20and_of_and%2C%0Aend%0A--%20END%0Aend%20hidden" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1203.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">and_comm</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&#8743;</span> <span class="n">s</span> <span class="bp">&#8596;</span> <span class="n">s</span> <span class="bp">&#8743;</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span>
  <span class="n">apply</span> <span class="n">and_of_and</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><div class="section" id="converse">
<h3><span class="section-number">1.7.1. </span>Converse<a class="headerlink" href="#converse" title="Permalink to this headline">&#182;</a></h3>
<p>Given a conditional <span class="math notranslate nohighlight">\(P\to Q\)</span>, its <em>converse</em> is the conditional <span class="math notranslate nohighlight">\(Q\to P\)</span>. The rules of
inference for iff effectively assert that to prove a biconditional <span class="math notranslate nohighlight">\(P \leftrightarrow Q\)</span>
is to prove a conditional <span class="math notranslate nohighlight">\(P\to Q\)</span> and its converse <span class="math notranslate nohighlight">\(Q\to P\)</span>.</p>
</div>
<div class="section" id="reflexivity-symmetry-transitivity-of-iff">
<span id="sec-refl-sym-trans-iff"></span><h3><span class="section-number">1.7.2. </span>Reflexivity, symmetry, transitivity of iff<a class="headerlink" href="#reflexivity-symmetry-transitivity-of-iff" title="Permalink to this headline">&#182;</a></h3>
<p>Iff has some particularly nice properties.</p>
<ul class="simple">
<li><p>Reflexivity. For every proposition <span class="math notranslate nohighlight">\(P\)</span>, we have <span class="math notranslate nohighlight">\(P\leftrightarrow P\)</span>.</p></li>
<li><p>Symmetry. For all propositions <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>, given <span class="math notranslate nohighlight">\(h : P \leftrightarrow Q\)</span>,
we have <span class="math notranslate nohighlight">\(Q \leftrightarrow P\)</span>.</p></li>
<li><p>Transitivity. For all propositions <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span>, given
<span class="math notranslate nohighlight">\(h_1 : P \leftrightarrow Q\)</span> and <span class="math notranslate nohighlight">\(h_2 : Q \leftrightarrow R\)</span>, we have
<span class="math notranslate nohighlight">\(P \leftrightarrow R\)</span>.</p></li>
</ul>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Reflexivity)</span>
        
    </div><div class="proof-content">
<p>By iff introduction, it suffices to prove <span class="math notranslate nohighlight">\(P\to P\)</span> and <span class="math notranslate nohighlight">\(P \to P\)</span>. Both these goals
are closed by <a class="reference internal" href="#thm-reflexivity-imp"><span class="std std-numref">Theorem 1.15</span></a>, the reflexivity of implication.</p>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20(p%20%3A%20Prop)%0A%0A--%20BEGIN%0Aexample%20%3A%20p%20%E2%86%94%20p%20%3A%3D%0Abegin%0A%20%20split%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20iff%20introduction%2C%20it%20suffices%20to%20prove%20%60p%20%E2%86%92%20p%60%20and%20%60p%20%E2%86%92%20p%60%0A%20%20%7B%20show%20p%20%E2%86%92%20p%2C%20from%20id%20%7D%2C%20--%20We%20show%20%60p%20%E2%86%92%20p%60%20from%20reflexivity%20of%20implication.%0A%20%20%7B%20show%20p%20%E2%86%92%20p%2C%20from%20id%20%7D%2C%20--%20We%20show%20%60p%20%E2%86%92%20p%60%20from%20reflexivity%20of%20implication.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1252.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>                   <span class="c1">-- By iff introduction, it suffices to prove `p &#8594; p` and `p &#8594; p`</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">id</span> <span class="o">},</span> <span class="c1">-- We show `p &#8594; p` from reflexivity of implication.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">id</span> <span class="o">},</span> <span class="c1">-- We show `p &#8594; p` from reflexivity of implication.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>As in our Lean proof of <a class="reference internal" href="#thm-and-comm3"><span class="std std-numref">Theorem 1.25</span></a>, we may employ the  <code class="docutils literal notranslate"><span class="pre">;</span></code> tactic
combinator to combine the proofs of the two subgoals that arise from the use of the <code class="docutils literal notranslate"><span class="pre">split</span></code> tactic.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20(p%20%3A%20Prop)%0A%0A--%20BEGIN%0Aexample%20%3A%20p%20%E2%86%94%20p%20%3A%3D%0Abegin%0A%20%20split%3B%20%20%20%20%20%20%20%20--%20By%20iff%20introduction%2C%20it%20suffices%20to%20prove%20%60p%20%E2%86%92%20p%60%20and%20%60p%20%E2%86%92%20p%60.%0A%20%20%7B%20exact%20id%20%7D%2C%20--%20We%20close%20both%20subgoals%20by%20reflexivity%20of%20implication.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1268.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span>        <span class="c1">-- By iff introduction, it suffices to prove `p &#8594; p` and `p &#8594; p`.</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">id</span> <span class="o">},</span> <span class="c1">-- We close both subgoals by reflexivity of implication.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The proof of symmetry of iff is almost identical to the proof of
<a class="reference internal" href="#example-and-comm1"><span class="std std-numref">Exampe 1.5</span></a>, the commutativity of conjunction.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Symmetry of iff)</span>
        
    </div><div class="proof-content">
<p>By iff introduction, it suffices to prove <span class="math notranslate nohighlight">\(Q\to P\)</span> and <span class="math notranslate nohighlight">\(P \to Q\)</span>.
We show <span class="math notranslate nohighlight">\(Q \to P\)</span> by right iff elimination on <span class="math notranslate nohighlight">\(h\)</span>. We show <span class="math notranslate nohighlight">\(P\to Q\)</span> by left iff
elimination on <span class="math notranslate nohighlight">\(h\)</span>.</p>
</div></div><p>The Lean proof is virtually identical that that of <a class="reference internal" href="#example-and-comm1"><span class="std std-numref">Exampe 1.5</span></a></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20(p%20q%20%3A%20Prop)%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%86%94%20q)%20%3A%20q%20%E2%86%94%20p%20%3A%3D%0Abegin%0A%20%20split%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20iff%20introduction%2C%20it%20suffices%20to%20prove%20%60q%20%E2%86%92%20p%60%20and%20%60p%20%E2%86%92%20q%60.%0A%20%20%7B%20show%20q%20%E2%86%92%20p%2C%20from%20h.2%20%7D%2C%20--%20We%20show%20%60q%20%E2%86%92%20p%60%20by%20right%20iff%20elimination%20on%20%60h%60.%0A%20%20%7B%20show%20p%20%E2%86%92%20q%2C%20from%20h.1%20%7D%2C%20--%20We%20show%20%60p%20%E2%86%92%20q%60%20by%20left%20iff%20elimination%20on%20%60h%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1291.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8596;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>                    <span class="c1">-- By iff introduction, it suffices to prove `q &#8594; p` and `p &#8594; q`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.2</span> <span class="o">},</span> <span class="c1">-- We show `q &#8594; p` by right iff elimination on `h`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h.1</span> <span class="o">},</span> <span class="c1">-- We show `p &#8594; q` by left iff elimination on `h`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We now proof transitivity. That is, given <span class="math notranslate nohighlight">\(h_1 : P \leftrightarrow Q\)</span> and
<span class="math notranslate nohighlight">\(h_2 : Q \leftrightarrow R\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P \leftrightarrow R\)</span>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Transitivity of iff)</span>
        
    </div><div class="proof-content">
<p>By iff introduction, it suffices to prove 1. <span class="math notranslate nohighlight">\(P\to R\)</span> and 2. <span class="math notranslate nohighlight">\(R\to P\)</span>.</p>
<ol class="arabic simple">
<li><p>We show <span class="math notranslate nohighlight">\(P\to R\)</span>. Applying the transtivity of implication
(<a class="reference internal" href="#thm-imp-trans1"><span class="std std-numref">Theorem 1.18</span></a>), it suffices to prove a. <span class="math notranslate nohighlight">\(P\to A\)</span> and
b. <span class="math notranslate nohighlight">\(A\to R\)</span> (for some proposition <span class="math notranslate nohighlight">\(A\)</span>).</p>
<ol class="loweralpha simple">
<li><p>We show <span class="math notranslate nohighlight">\(P\to Q\)</span> by left iff eliminiation on <span class="math notranslate nohighlight">\(h_1\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(Q\to R\)</span> by left iff elimination on <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
</ol>
</li>
<li><p>The proof of <span class="math notranslate nohighlight">\(R\to P\)</span> is similar and is left to the reader.</p></li>
</ol>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A%0Atheorem%20imp_trans1%20%3A%20(p%20%E2%86%92%20q)%20%E2%86%92%20(q%20%E2%86%92%20r)%20%E2%86%92%20(p%20%E2%86%92%20r)%20%3A%3D%0A%CE%BB%20h%E2%82%81%20h%E2%82%82%20h%E2%82%83%2C%20h%E2%82%82%20(h%E2%82%81%20h%E2%82%83)%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20p%20%E2%86%94%20q)%20(h%E2%82%82%20%3A%20q%20%E2%86%94%20r)%20%3A%20p%20%E2%86%94%20r%20%3A%3D%0Abegin%0A%20%20split%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20iff%20intro.%2C%20it%20suffices%20to%20prove%20%60p%20%E2%86%92%20r%60%20and%20%60r%20%E2%86%92%20p%60.%0A%20%20%7B%20show%20p%20%E2%86%92%20r%2C%20apply%20imp_trans1%2C%20%20%20--%20We%20show%20%60p%20%E2%86%92%20r%60.%20By%20transitivity%20of%20%60%E2%86%92%60%2C%20it%20suffices%20to%20prove%20%60p%20%E2%86%92%20%3F%60%20and%20%60%3F%20%E2%86%92%20r%60.%0A%20%20%20%20%7B%20show%20p%20%E2%86%92%20q%2C%20from%20h%E2%82%81.1%2C%20%7D%2C%20%20%20%20%20--%20We%20show%20%60p%20%E2%86%92%20q%60%20by%20left%20iff%20elimination%20on%20%60h%E2%82%81%60.%0A%20%20%20%20%7B%20show%20q%20%E2%86%92%20r%2C%20from%20h%E2%82%82.1%2C%20%7D%2C%20%7D%2C%20%20--%20We%20show%20%60q%20%E2%86%92%20r%60%20by%20left%20iff%20elimination%20on%20%60h%E2%82%82%60.%0A%20%7B%20show%20r%20%E2%86%92%20p%2C%20sorry%20%20%7D%2C%20%20%20%20%20%20%20%20%20%20%20%20--%20The%20proof%20of%20%60r%20%E2%86%92%20p%60%20is%20left%20to%20the%20reader.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1322.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8596;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>                            <span class="c1">-- By iff intro., it suffices to prove `p &#8594; r` and `r &#8594; p`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">,</span> <span class="n">apply</span> <span class="n">imp_trans1</span><span class="o">,</span>   <span class="c1">-- We show `p &#8594; r`. By transitivity of `&#8594;`, it suffices to prove `p &#8594; ?` and `? &#8594; r`.</span>
    <span class="o">{</span> <span class="k">show</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;.1</span><span class="o">,</span> <span class="o">},</span>     <span class="c1">-- We show `p &#8594; q` by left iff elimination on `h&#8321;`.</span>
    <span class="o">{</span> <span class="k">show</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8322;.1</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>  <span class="c1">-- We show `q &#8594; r` by left iff elimination on `h&#8322;`.</span>
 <span class="o">{</span> <span class="k">show</span> <span class="n">r</span> <span class="bp">&#8594;</span> <span class="n">p</span><span class="o">,</span> <span class="n">sorry</span>  <span class="o">},</span>            <span class="c1">-- The proof of `r &#8594; p` is left to the reader.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="rewriting">
<span id="sec-rewriting"></span><h2><span class="section-number">1.8. </span>Rewriting<a class="headerlink" href="#rewriting" title="Permalink to this headline">&#182;</a></h2>
<p>Whenever two propositions <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> are judged to be equal, the proposition <span class="math notranslate nohighlight">\(P\)</span>
can be replaced with <span class="math notranslate nohighlight">\(P\)</span>, wherever <span class="math notranslate nohighlight">\(P\)</span> appears. This process is called <em>rewriting</em>.
Technically, equality is a notion of predicate logic rather than propositional logic.</p>
<div class="section" id="rewriting-a-goal">
<h3><span class="section-number">1.8.1. </span>Rewriting a goal<a class="headerlink" href="#rewriting-a-goal" title="Permalink to this headline">&#182;</a></h3>
<p>We&#8217;ll use rewriting in proving the following result.</p>
<div class="proof proof-type-example" id="id34">

    <div class="proof-title">
        <span class="proof-type">Example 1.26</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(x, y, z\)</span> be natural numbers. Then <span class="math notranslate nohighlight">\(x * (y + z) = x * z + y * x\)</span>.</p>
</div></div><p>Our proof will call on the following intermediate results (which will be proved in due course).</p>
<div class="proof proof-type-theorem" id="id35">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.27</span>
        
            <span class="proof-title-name">((Left) distributivity of multiplication over addition)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(a, b, c\)</span> be natural numbers. Then <span class="math notranslate nohighlight">\(a * (b + c) = a * b + a * c\)</span>.</p>
</div></div><div class="proof proof-type-theorem" id="id36">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.28</span>
        
            <span class="proof-title-name">(Commutativity of addition)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> be natural numbers. Then <span class="math notranslate nohighlight">\(a + b = b + a\)</span>.</p>
</div></div><div class="proof proof-type-theorem" id="id37">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.29</span>
        
            <span class="proof-title-name">(Commutativity of multiplication)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> be natural numbers. Then <span class="math notranslate nohighlight">\(a * b = b * a\)</span>.</p>
</div></div><p>Returning to the example, we have to prove <span class="math notranslate nohighlight">\(x * (y + z) = x * z + y * x\)</span>. As a first
step, we can rewrite this using the left distributivity of multiplication over addition (or, more
simply, distributivity) applied to <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>. By application, I mean that the
variables <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> take the roles of <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(c\)</span>,
respectively in the distributive law.</p>
<p>The distributive law with these varaibles subsituted reads <span class="math notranslate nohighlight">\(x * (y + z) = x * y + x * z\)</span>.
We rewrite the goal using the proposition. The left side of the goal is replaced with the right side
of the preceding equation, changing the goal to one of proving <span class="math notranslate nohighlight">\(x * y + x * z = x * z + y * x\)</span>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Rewriting using distributivity applied to <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span>, the goal is to prove
<span class="math notranslate nohighlight">\(x * y + x * z = x * z + y * x\)</span>.</p>
<p>Rewriting using commutativity of addition applied to <span class="math notranslate nohighlight">\(x * y\)</span> and <span class="math notranslate nohighlight">\(x * z\)</span>, the goal is
to prove <span class="math notranslate nohighlight">\(x * z + x * y = x * z + y * x\)</span>.</p>
<p>Rewriting using commutativity of multiplication applied to  <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, the goal is
to prove <span class="math notranslate nohighlight">\(x * z + y * x = x * z + y * x\)</span>.</p>
<p>This is trivially true (formally, it&#8217;s true by reflexivity of <span class="math notranslate nohighlight">\(=\)</span>).</p>
</div></div><p>With two of the above rewrites, it isn&#8217;t stricly necessary to identify the variables being used.
For example, in the initial goal, the distributivity law could only possibly apply to the variables
<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> as there is no expression of the form <span class="math notranslate nohighlight">\(a * (b + c)\)</span> in
the goal except for <span class="math notranslate nohighlight">\(x * (y + z)\)</span>.</p>
<p>In Lean, we use the <code class="docutils literal notranslate"><span class="pre">rw</span></code> tactic to denote rewriting. Given <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>, the tactic <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">h</span></code>
will replace the first occurrence (reading left-to-right) of <code class="docutils literal notranslate"><span class="pre">P</span></code> with <code class="docutils literal notranslate"><span class="pre">Q</span></code>. If the
expression <code class="docutils literal notranslate"><span class="pre">h</span></code> depends on variables or other hypotheses, then Lean will look for the first
expression in the goal that matches the shape of <code class="docutils literal notranslate"><span class="pre">h</span></code> and instantiate variables as necessary.</p>
<p>In the code below, <code class="docutils literal notranslate"><span class="pre">mul_add</span></code> is the theorem that for all natural numbers <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>,
we have <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c)</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">c</span></code>. Lean matches the left side of this equation with
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">(y</span> <span class="pre">+</span> <span class="pre">z)</span></code> after instantiating <code class="docutils literal notranslate"><span class="pre">a</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> as <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> as <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<p>Having performed that rewrite, the goal becomes <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">x</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">add_comm</span></code> states that for all natural numbers <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, we have <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">a</span></code>.
There are <em>two</em> subexpressions in the goal <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">x</span></code> that match with
<code class="docutils literal notranslate"><span class="pre">add_comm</span></code>, namely <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span></code> and  <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">x</span></code>. However, Lean performs the rewrite on
the first subexpression that matches. In this case, it&#8217;s <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span></code>.</p>
<p>Having performed <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">add_comm</span></code>, the goal becomes <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">x</span></code>.</p>
<p>We need to be precise is our last rewrite. This rewrite involves the theorem <code class="docutils literal notranslate"><span class="pre">mul_comm</span></code> which
states that for all natural numbers <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, we have <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">a</span></code>. The first
subexpression of the goal to which this theorem applies is <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span></code>. That is, the result of
performing <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">mul_comm</span></code> would be identical to the result of performing <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">x</span> <span class="pre">z</span></code>, namely to
change the goal to <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">x</span></code>.</p>
<p>However, rewriting <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span></code> as <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">*</span> <span class="pre">x</span></code>
doesn&#8217;t resolve the goal! Instead, we need to rewrite applying <code class="docutils literal notranslate"><span class="pre">mul_comm</span></code> to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>This leaves, as a goal, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">z</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">x</span></code>. Lean automatically closes this goal
by the reflexivity of <code class="docutils literal notranslate"><span class="pre">=</span></code> (viz. the fact that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span></code>, for every <code class="docutils literal notranslate"><span class="pre">a</span></code>).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0A%0Avariables%20x%20y%20z%20%3A%20%E2%84%95%0A--%20BEGIN%0Aexample%20%3A%20x%20*%20(y%20%2B%20z)%20%3D%20x%20*%20z%20%2B%20y%20*%20x%20%3A%3D%0Abegin%0A%20%20rw%20mul_add%2C%0A%20%20rw%20add_comm%2C%0A%20%20rw%20mul_comm%20x%20y%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1431.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Several rewrites can be combined by enclosing them in brackets, as below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0A%0Avariables%20x%20y%20z%20%3A%20%E2%84%95%0A--%20BEGIN%0Aexample%20%3A%20x%20*%20(y%20%2B%20z)%20%3D%20x%20*%20z%20%2B%20y%20*%20x%20%3A%3D%0Aby%20rw%20%5Bmul_add%2C%20add_comm%2C%20mul_comm%20x%20y%5D%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1447.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">add_comm</span><span class="o">,</span> <span class="n">mul_comm</span> <span class="n">x</span> <span class="n">y</span><span class="o">]</span>
</pre></div>
</div>
</div></div>
<div class="section" id="rewriting-a-hypothesis">
<h3><span class="section-number">1.8.2. </span>Rewriting a hypothesis<a class="headerlink" href="#rewriting-a-hypothesis" title="Permalink to this headline">&#182;</a></h3>
<p>Given a hypothesis <span class="math notranslate nohighlight">\(h : P = Q\)</span>, we can rewrite any other hypothesis <span class="math notranslate nohighlight">\(k\)</span> by replacing
occurrences of <span class="math notranslate nohighlight">\(P\)</span> in <span class="math notranslate nohighlight">\(k\)</span> with <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<div class="proof proof-type-example" id="id38">

    <div class="proof-title">
        <span class="proof-type">Example 1.30</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(x, y, z\)</span> be natural numbers. Given <span class="math notranslate nohighlight">\(k : y * x = z\)</span>, we have
<span class="math notranslate nohighlight">\(x * (y + z) = z + x * z\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Rewrite using commutativity of multiplication at <span class="math notranslate nohighlight">\(k\)</span> to give <span class="math notranslate nohighlight">\(k : x * y = z\)</span>.</p>
<p>Rewrite using distributivity. The goal is <span class="math notranslate nohighlight">\(x * y + x * z = z + x * z\)</span>.</p>
<p>Rewrite using <span class="math notranslate nohighlight">\(k\)</span>. The goal is <span class="math notranslate nohighlight">\(z + x * z = z + x * z\)</span>, which is trivially true.</p>
</div></div><p>The Lean version of &#8216;rewrite using <span class="math notranslate nohighlight">\(h\)</span> at <span class="math notranslate nohighlight">\(k\)</span>&#8217; is <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">h</span> <span class="pre">at</span> <span class="pre">k</span></code> as shown below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0A%0Avariables%20x%20y%20z%20%3A%20%E2%84%95%0A--%20BEGIN%0Aexample%20(k%20%3A%20y%20*%20x%20%3D%20z)%20%3A%20x%20*%20(y%20%2B%20z)%20%3D%20z%20%2B%20x%20*%20z%20%3A%3D%0Abegin%0A%20%20rw%20mul_comm%20at%20k%2C%0A%20%20rw%20mul_add%2C%0A%20%20rw%20k%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1478.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">*</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">z</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="o">(</span><span class="n">y</span> <span class="bp">+</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span> <span class="n">z</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">z</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">mul_comm</span> <span class="n">at</span> <span class="n">k</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_add</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">k</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="rewriting-in-reverse">
<h3><span class="section-number">1.8.3. </span>Rewriting in reverse<a class="headerlink" href="#rewriting-in-reverse" title="Permalink to this headline">&#182;</a></h3>
<p>Given a hypothesis <span class="math notranslate nohighlight">\(h : P = Q\)</span>, we&#8217;ve seen that we  can rewrite the goal (or another hypothesis)
by replacing occurrences of <span class="math notranslate nohighlight">\(P\)</span> with <span class="math notranslate nohighlight">\(Q\)</span>. However, by symmetry of <span class="math notranslate nohighlight">\(=\)</span>, we can
express <span class="math notranslate nohighlight">\(h\)</span> as <span class="math notranslate nohighlight">\(h : Q = P\)</span> and then go on to replace occurrences of <span class="math notranslate nohighlight">\(Q\)</span> in the
goal (or another hypothesis) by <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>We may refer to this process as &#8216;rewriting using <span class="math notranslate nohighlight">\(h\)</span> in reverse&#8217;.</p>
<p>Recall that the distributive law states <span class="math notranslate nohighlight">\(a * (b + c) = a * b + a * c\)</span>.
We can use this (in reverse) to rewrite the expression <span class="math notranslate nohighlight">\(x * y + x * z = (z + y) * x\)</span> as
<span class="math notranslate nohighlight">\(x * (y + z) = (z + y) * x\)</span>. This is the first step in the proof of the following result.</p>
<div class="proof proof-type-example" id="id39">

    <div class="proof-title">
        <span class="proof-type">Example 1.31</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> be natural numbers. Then
<span class="math notranslate nohighlight">\(x * y + x * z = (z + y) * x\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Rewriting using the distributive law (in reverse), the goal is <span class="math notranslate nohighlight">\(x * (y + z) = (z + y) * x\)</span>.</p>
<p>Rewriting using the commutativity of multiplication, the goal is <span class="math notranslate nohighlight">\((y + z) * x = (z + y) * x\)</span>.</p>
<p>Rewriting using the commutativity of addition, the goal is <span class="math notranslate nohighlight">\((z + y) * x = (z + y) * x\)</span>.
This is trivially true.</p>
</div></div><p>In Lean, we denote rewriting using <code class="docutils literal notranslate"><span class="pre">h</span></code> in reverse as <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">&#8592;mul_add</span></code>, as in the example below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0A%0Avariables%20x%20y%20z%20%3A%20%E2%84%95%0A--%20BEGIN%0Aexample%20%3A%20x%20*%20y%20%2B%20x%20*%20z%20%3D%20(z%20%2B%20y)%20*%20x%20%3A%3D%0Abegin%0A%20%20rw%20%E2%86%90mul_add%2C%0A%20%20rw%20add_comm%2C%0A%20%20rw%20mul_comm%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1522.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">z</span> <span class="bp">=</span> <span class="o">(</span><span class="n">z</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">&#8592;</span><span class="n">mul_add</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">add_comm</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mul_comm</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="propositional-extensionality-and-rewriting">
<h2><span class="section-number">1.9. </span>Propositional extensionality and rewriting<a class="headerlink" href="#propositional-extensionality-and-rewriting" title="Permalink to this headline">&#182;</a></h2>
<p>In advanced courses on mathematical logic (for the avoidance of doubt, this is not an advanced course),
one typically proves theorems <em>about</em> systems of logic. One such theorem is that given propositions
<span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> and given <span class="math notranslate nohighlight">\(h : P \leftrightarrow Q\)</span>, if the proposition <span class="math notranslate nohighlight">\(Q\)</span> is
substituted for <span class="math notranslate nohighlight">\(P\)</span> wherever <span class="math notranslate nohighlight">\(P\)</span> appears in a theorem then result will still be a
theorem.</p>
<p>We will not prove this theorem of meta propositional logic but we pause to note that the reflexivity,
symmetry, and transitivity properties of <span class="math notranslate nohighlight">\(\leftrightarrow\)</span>, when taken together, suggest
very strongly that propositions <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> should be treated as equal if
<span class="math notranslate nohighlight">\(P\leftrightarrow Q\)</span>.</p>
<p>To simplify matters, we will take treat this theorem as a rule, the principle of propositional
extensionality.</p>
<div class="proof proof-type-mathsrule" id="id40">

    <div class="proof-title">
        <span class="proof-type">Rule 1.32</span>
        
            <span class="proof-title-name">(Propositional extensionality)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : P \leftrightarrow Q\)</span>, we have
<span class="math notranslate nohighlight">\(P = Q\)</span>.</p>
</div></div><div class="section" id="id1">
<h3><span class="section-number">1.9.1. </span>Rewriting a goal<a class="headerlink" href="#id1" title="Permalink to this headline">&#182;</a></h3>
<p>Given <span class="math notranslate nohighlight">\(h : P \leftrightarrow Q\)</span>, we can denote the use of propositional extensionality on the
by writing, &#8216;Rewriting using <span class="math notranslate nohighlight">\(h\)</span>, the goal is &#8230;&#8217;, as in <a class="reference internal" href="#sec-rewriting"><span class="std std-numref">Section 1.8</span></a>.
We use this form of expression in the examples below.</p>
<p>In our first example, we use propositional extensionality to give a quick proof of transitivity of
implication. Given <span class="math notranslate nohighlight">\(h_1 : P \leftrightarrow Q\)</span> and <span class="math notranslate nohighlight">\(h_2 : Q \leftrightarrow R\)</span> we have
a proof of <span class="math notranslate nohighlight">\(P \leftrightarrow R\)</span>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Rewriting using <span class="math notranslate nohighlight">\(h_1\)</span>, the goal is to prove prove <span class="math notranslate nohighlight">\(Q \leftrightarrow R\)</span>.
This holds by reiteration on <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
</div></div><p>Compare this to the rather more involved proof given in <a class="reference internal" href="#sec-refl-sym-trans-iff"><span class="std std-numref">Section 1.7.2</span></a>.</p>
<p>In Lean, we use the <code class="docutils literal notranslate"><span class="pre">rw</span></code> tactic to rewrite the goal.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20p%20%E2%86%94%20q)%20(h%E2%82%82%20%3A%20q%20%E2%86%94%20r)%20%3A%20p%20%E2%86%94%20r%20%3A%3D%0Abegin%0A%20%20rw%20h%E2%82%81%2C%20%20%20%20--%20Rewriting%20using%20%60h%E2%82%81%60%2C%20the%20goal%20is%20to%20prove%20%60q%20%E2%86%94%20r%60.%0A%20%20exact%20h%E2%82%82%2C%20--%20This%20holds%20by%20reiteration%20on%20%60h%E2%82%82%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1578.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8596;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">h&#8321;</span><span class="o">,</span>    <span class="c1">-- Rewriting using `h&#8321;`, the goal is to prove `q &#8596; r`.</span>
  <span class="n">exact</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="c1">-- This holds by reiteration on `h&#8322;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>In the next example, we rewrite using De Morgan&#8217;s law <a class="footnote-reference brackets" href="#id3" id="id2">1</a> <span class="math notranslate nohighlight">\(\neg(P \lor Q) \leftrightarrow
\neg P \land \neg Q\)</span> and our commtativity of conjunction result,
<a class="reference internal" href="#thm-and-comm3"><span class="std std-numref">Theorem 1.25</span></a>.</p>
<div class="proof proof-type-example" id="id41">

    <div class="proof-title">
        <span class="proof-type">Example 1.33</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(\neg(P \lor Q) \leftrightarrow
\neg Q \land \neg P\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Rewriting using De Morgan&#8217;s law, the goal is to prove
<span class="math notranslate nohighlight">\(\neg P \land \neg Q \leftrightarrow \neg Q \land\neg P\)</span>. This holds by applying
commutativity of conjunction.</p>
</div></div><p>In the Lean proof below, <code class="docutils literal notranslate"><span class="pre">not_or_distrib</span></code> is the name of the relvant De Morgan&#8217;s law.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20logic.basic%0A%0Avariables%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20%3A%20%C2%AC(p%20%E2%88%A8%20q)%20%E2%86%94%20%C2%ACq%20%E2%88%A7%20%C2%ACp%20%3A%3D%0Abegin%0A%20%20rw%20not_or_distrib%2C%20--%20Rewrite%20using%20De%20Morgan's%20law.%20The%20goal%20is%20%60%C2%ACp%20%E2%88%A7%20%C2%ACq%20%E2%86%94%20%C2%ACq%20%E2%88%A7%20%C2%ACp%60.%0A%20%20apply%20and_comm%2C%20%20%20%20--%20This%20holds%20by%20applying%20commutativity%20of%20conjunction.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1607.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">not_or_distrib</span><span class="o">,</span> <span class="c1">-- Rewrite using De Morgan&#39;s law. The goal is `&#172;p &#8743; &#172;q &#8596; &#172;q &#8743; &#172;p`.</span>
  <span class="n">apply</span> <span class="n">and_comm</span><span class="o">,</span>    <span class="c1">-- This holds by applying commutativity of conjunction.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>We&#8217;ll prove this later as <a class="reference internal" href="#thm-not-or-distrib"><span class="std std-numref">Theorem 1.56</span></a>. Another of De Morgan&#8217;s
laws is <a class="reference internal" href="#thm-not-and-distrib"><span class="std std-numref">Theorem 1.62</span></a>, which asserts
<span class="math notranslate nohighlight">\(\neg(P\land Q) \leftrightarrow\neg P\lor\neg Q\)</span>.</p>
</dd>
</dl>
</div>
<div class="section" id="id4">
<h3><span class="section-number">1.9.2. </span>Rewriting a hypothesis<a class="headerlink" href="#id4" title="Permalink to this headline">&#182;</a></h3>
<p>We can use rewriting (i.e. propositional extensionality) on hypotheses just as we can on goals.</p>
<div class="proof proof-type-example" id="id42">
<span id="example-rumtumtugger"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.34</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Given <span class="math notranslate nohighlight">\(k : \neg(P \lor Q)\)</span>, we have a proof of
<span class="math notranslate nohighlight">\(\neg Q \land \neg P\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Rewriting using De Morgan&#8217;s law at <span class="math notranslate nohighlight">\(k\)</span>, we have <span class="math notranslate nohighlight">\(k : \neg P \land \neg Q\)</span>.
Rewriting using commutativity of conjunction, the goal is <span class="math notranslate nohighlight">\(\neg P \land \neg Q\)</span>.
The result follows by reiteration on <span class="math notranslate nohighlight">\(k\)</span>.</p>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20logic.basic%0A%0Avariables%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(k%20%3A%20%C2%AC(p%20%E2%88%A8%20q))%20%3A%20%C2%ACq%20%E2%88%A7%20%C2%ACp%20%3A%3D%0Abegin%0A%20%20rw%20not_or_distrib%20at%20k%2C%20--%20Rewriting%20using%20De%20Morgan's%20law%20at%20%60k%60%2C%20we%20have%20%60k%20%3A%20%C2%ACp%20%E2%88%A7%20%C2%ACq%60.%0A%20%20rw%20and_comm%2C%20%20%20%20%20%20%20%20%20%20%20%20--%20Rewriting%20using%20commutativity%20of%20conjunction%2C%20the%20goal%20is%20%60%C2%ACp%20%E2%88%A7%20%C2%ACq%60.%0A%20%20exact%20k%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20This%20holds%20by%20reiteration%20on%20%60k%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1643.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">not_or_distrib</span> <span class="n">at</span> <span class="n">k</span><span class="o">,</span> <span class="c1">-- Rewriting using De Morgan&#39;s law at `k`, we have `k : &#172;p &#8743; &#172;q`.</span>
  <span class="n">rw</span> <span class="n">and_comm</span><span class="o">,</span>            <span class="c1">-- Rewriting using commutativity of conjunction, the goal is `&#172;p &#8743; &#172;q`.</span>
  <span class="n">exact</span> <span class="n">k</span><span class="o">,</span>                <span class="c1">-- This holds by reiteration on `k`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="id5">
<h3><span class="section-number">1.9.3. </span>Rewriting in reverse<a class="headerlink" href="#id5" title="Permalink to this headline">&#182;</a></h3>
<p>Given <span class="math notranslate nohighlight">\(h : P \leftrightarrow Q\)</span> to rewrite using <span class="math notranslate nohighlight">\(h\)</span> in reverse is to replace occurrences
of <span class="math notranslate nohighlight">\(Q\)</span> in the goal (or in another hypothesis) with <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>By rewriting in reverse, we give an alternative proof of <a class="reference internal" href="#example-rumtumtugger"><span class="std std-numref">Example 1.34</span></a>.
For this, we need the commutative law of disjunction (to be proved later). Namely, given propositions
<span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span>, we have <span class="math notranslate nohighlight">\(S \lor T \leftrightarrow T \lor S\)</span>.</p>
<p>We are now in a position to prove <a class="reference internal" href="#example-rumtumtugger"><span class="std std-numref">Example 1.34</span></a>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Rewriting using De Morgan&#8217;s law in reverse, the goal is <span class="math notranslate nohighlight">\(\neg(Q \lor P)\)</span>.</p>
<p>Rewriting using commutativity of disjunction, the goal is <span class="math notranslate nohighlight">\(\neg(P \lor Q)\)</span>.</p>
<p>We close the goal by reiteration on <span class="math notranslate nohighlight">\(k\)</span>.</p>
</div></div><p>As in <a class="reference internal" href="#sec-rewriting"><span class="std std-numref">Section 1.8</span></a>, we denote rewriting using <code class="docutils literal notranslate"><span class="pre">h</span></code> in reverse as
<code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">&#8592;mul_add</span></code>, as in the example below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20logic.basic%0A%0Avariables%20p%20q%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC(p%20%E2%88%A8%20q))%20%3A%20%C2%ACq%20%E2%88%A7%20%C2%ACp%20%3A%3D%0Abegin%0A%20%20rw%20%E2%86%90not_or_distrib%2C%0A%20%20rw%20or_comm%2C%0A%20%20exact%20h%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1682.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">&#8592;</span><span class="n">not_or_distrib</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">or_comm</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="disjunction">
<h2><span class="section-number">1.10. </span>Disjunction<a class="headerlink" href="#disjunction" title="Permalink to this headline">&#182;</a></h2>
<div class="section" id="disjunction-introduction">
<h3><span class="section-number">1.10.1. </span>Disjunction introduction<a class="headerlink" href="#disjunction-introduction" title="Permalink to this headline">&#182;</a></h3>
<p>There are two disjunction introduction rules, left and right. Each comes in both a forward and a
backward flavour.</p>
<div class="proof proof-type-mathsrule" id="id43">

    <div class="proof-title">
        <span class="proof-type">Rule 1.35</span>
        
            <span class="proof-title-name">(Disjunction introduction, forward)</span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>(<em>Left or introduction</em>) given <span class="math notranslate nohighlight">\(h : P\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P \lor Q\)</span>.</p></li>
<li><p>(<em>Right or introduction</em>) given <span class="math notranslate nohighlight">\(h : Q\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P \lor Q\)</span>.</p></li>
</ul>
</div></div><div class="proof proof-type-example" id="id44">
<span id="example-s-or-t-or-u-intro"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.36</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(S\)</span>, <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(U\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : T\)</span>, we have
<span class="math notranslate nohighlight">\(S \lor (T \lor U)\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Forward)</span>
        
    </div><div class="proof-content">
<p>We have <span class="math notranslate nohighlight">\(h_2 : T \lor U\)</span> by left or introduction on <span class="math notranslate nohighlight">\(h\)</span>. The result follows by right
or introduction on <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
</div></div><p>In Lean, given <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">or.inl</span> <span class="pre">h</span></code> is a proof term for <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>. Given, <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">q</span></code>,
the expression <code class="docutils literal notranslate"><span class="pre">or.inr</span> <span class="pre">h</span></code> is a proof term for <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20s%20t%20u%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20t)%20%3A%20s%20%E2%88%A8%20(t%20%E2%88%A8%20u)%20%3A%3D%0Abegin%0A%20%20have%20h%E2%82%82%20%3A%20t%20%E2%88%A8%20u%2C%20from%20or.inl%20h%2C%0A%20%20exact%20or.inr%20h%E2%82%82%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1730.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">t</span> <span class="bp">&#8744;</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">&#8744;</span> <span class="n">u</span><span class="o">,</span> <span class="k">from</span> <span class="n">or.inl</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">or.inr</span> <span class="n">h&#8322;</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><div class="proof proof-type-mathsrule" id="id45">

    <div class="proof-title">
        <span class="proof-type">Rule 1.37</span>
        
            <span class="proof-title-name">(Disjunction introduction, backward)</span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>(<em>Left or introduction</em>) to prove <span class="math notranslate nohighlight">\(P \lor Q\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(P\)</span>.</p></li>
<li><p>(<em>Right or introduction</em>) to prove <span class="math notranslate nohighlight">\(P \lor Q\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(Q\)</span>.</p></li>
</ul>
</div></div><p>We give a backward proof of <a class="reference internal" href="#example-s-or-t-or-u-intro"><span class="std std-numref">Example 1.36</span></a>.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
            <span class="proof-title-name">(Backward)</span>
        
    </div><div class="proof-content">
<p>We show <span class="math notranslate nohighlight">\(S \lor (T \lor U)\)</span>. By backward right or introduction, it suffices to prove
<span class="math notranslate nohighlight">\(T\lor U\)</span>. By backward left introduction, it suffices to prove <span class="math notranslate nohighlight">\(T\)</span>.
We show <span class="math notranslate nohighlight">\(T\)</span> by reiteration on <span class="math notranslate nohighlight">\(h\)</span>.</p>
</div></div><p>The Lean tactic for backward left or introduction is <code class="docutils literal notranslate"><span class="pre">left</span></code>. That for backward right or
introduction is <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20s%20t%20u%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20t)%20%3A%20s%20%E2%88%A8%20(t%20%E2%88%A8%20u)%20%3A%3D%0Abegin%0A%20%20right%2C%20%20%20%20%20%20%20%20%20%20%20--%20By%20right%20or%20introduction%2C%20it%20suffices%20to%20prove%20%60t%20%E2%88%A8%20u%60.%0A%20%20left%2C%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20left%20or%20introduction%2C%20it%20suffice%20to%20prove%20%60t%60.%0A%20%20show%20t%2C%20from%20h%2C%20%20--%20We%20show%20%60t%60%20by%20reiteration%20on%20%60h%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1762.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">t</span> <span class="bp">&#8744;</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">right</span><span class="o">,</span>           <span class="c1">-- By right or introduction, it suffices to prove `t &#8744; u`.</span>
  <span class="n">left</span><span class="o">,</span>            <span class="c1">-- By left or introduction, it suffice to prove `t`.</span>
  <span class="k">show</span> <span class="n">t</span><span class="o">,</span> <span class="k">from</span> <span class="n">h</span><span class="o">,</span>  <span class="c1">-- We show `t` by reiteration on `h`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="disjunction-elimination">
<h3><span class="section-number">1.10.2. </span>Disjunction elimination<a class="headerlink" href="#disjunction-elimination" title="Permalink to this headline">&#182;</a></h3>
<p>This is the most challenging rule so far. We start with an example.</p>
<p>Suppose we know of Peggy that she keeps rabbits or she grows strawberries.
Further, we have 1. if Peggy keeps rabbits, then she needs straw as bedding material for the rabbits.
We also have 2. if Peggy grows strawberries, then she needs straw to keep the strawberries off the
ground and help keep them clean. We deduce that Peggy needs straw.</p>
<p>The deduction here is an application of disjunction elimination.</p>
<div class="proof proof-type-mathsrule" id="id46">

    <div class="proof-title">
        <span class="proof-type">Rule 1.38</span>
        
            <span class="proof-title-name">(Disjunction elimination, backward)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : P \lor Q\)</span>, to prove
<span class="math notranslate nohighlight">\(R\)</span>, it suffices 1. to show <span class="math notranslate nohighlight">\(R\)</span> on the assumption <span class="math notranslate nohighlight">\(h_1 : P\)</span> and 2. to show
<span class="math notranslate nohighlight">\(R\)</span> on the assumption <span class="math notranslate nohighlight">\(h_2 : Q\)</span>.</p>
</div></div><p>Here is an archetypal example of backward disjunction elimination.</p>
<div class="proof proof-type-example" id="id47">

    <div class="proof-title">
        <span class="proof-type">Example 1.39</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : P \lor Q\)</span>,
<span class="math notranslate nohighlight">\(k_1 : P \to R\)</span>, and <span class="math notranslate nohighlight">\(k_2 : Q\to R\)</span>, we have a proof of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By or elimination on <span class="math notranslate nohighlight">\(h\)</span>, it suffices 1. to show <span class="math notranslate nohighlight">\(R\)</span> on the assumption <span class="math notranslate nohighlight">\(h_1 : P\)</span>
and 2. to show <span class="math notranslate nohighlight">\(R\)</span> on the assumption <span class="math notranslate nohighlight">\(h_2 : Q\)</span>.</p>
<ol class="arabic simple">
<li><p>We show <span class="math notranslate nohighlight">\(R\)</span> by implication elimination on <span class="math notranslate nohighlight">\(k_1\)</span> and <span class="math notranslate nohighlight">\(h_1\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(R\)</span> by implication elimination on <span class="math notranslate nohighlight">\(k_2\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
</ol>
</div></div><p>The Lean tactic used for decomposing a conjunction is <code class="docutils literal notranslate"><span class="pre">cases</span></code>. Suppose the current goal is <code class="docutils literal notranslate"><span class="pre">r</span></code>.
Given <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">h</span> <span class="pre">with</span> <span class="pre">h&#8321;</span> <span class="pre">h&#8322;</span></code> causes Lean to create two new goals.
1. to prove <code class="docutils literal notranslate"><span class="pre">r</span></code> with <code class="docutils literal notranslate"><span class="pre">h&#8321;</span> <span class="pre">:</span> <span class="pre">p</span></code> added to the context and 2. to prove <code class="docutils literal notranslate"><span class="pre">r</span></code> with <code class="docutils literal notranslate"><span class="pre">h&#8322;</span> <span class="pre">:</span> <span class="pre">q</span></code> added
to the context.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A8%20q)%20(k%E2%82%81%20%3A%20p%20%E2%86%92%20r)%20(k%E2%82%82%20%3A%20q%20%E2%86%92%20r)%20%3A%20r%20%3A%3D%0Abegin%0A--%20By%20or%20elim.%20on%20%60h%60%2C%20it%20suffices%0A%20%20--%201.%20to%20show%20%60r%60%20on%20the%20assumption%20%60h%E2%82%81%20%3A%20p%60%20and%0A%20%20--%202.%20to%20show%20%60r%60%20on%20the%20assumption%20%60h%E2%82%82%20%3A%20q%60.%0A%20%20cases%20h%20with%20h%E2%82%81%20h%E2%82%82%2C%0A%20%20%7B%20show%20r%2C%20from%20k%E2%82%81%20h%E2%82%81%2C%20%7D%2C%20--%20We%20show%20%60r%60%20by%20implication%20elimination%20on%20%60k%E2%82%81%60%20and%20%60h%E2%82%81%60.%0A%20%20%7B%20show%20r%2C%20from%20k%E2%82%82%20h%E2%82%82%2C%20%7D%2C%20--%20We%20show%20%60r%60%20by%20implication%20elimination%20on%20%60k%E2%82%82%60%20and%20%60h%E2%82%82%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1815.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">k&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">k&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">-- By or elim. on `h`, it suffices</span>
  <span class="c1">-- 1. to show `r` on the assumption `h&#8321; : p` and</span>
  <span class="c1">-- 2. to show `r` on the assumption `h&#8322; : q`.</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">k&#8321;</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- We show `r` by implication elimination on `k&#8321;` and `h&#8321;`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">r</span><span class="o">,</span> <span class="k">from</span> <span class="n">k&#8322;</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- We show `r` by implication elimination on `k&#8322;` and `h&#8322;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The forward disjunction elimination rule is a restatement of the result just proved.</p>
<div class="proof proof-type-mathsrule" id="id48">

    <div class="proof-title">
        <span class="proof-type">Rule 1.40</span>
        
            <span class="proof-title-name">(Disjunction elimination, forward)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : P \lor Q\)</span>,
<span class="math notranslate nohighlight">\(k_1 : P \to R\)</span> and <span class="math notranslate nohighlight">\(k_2 : Q \to R\)</span>, we have a proof of <span class="math notranslate nohighlight">\(R\)</span>.</p>
</div></div><p>The parallel between the forward and backward versions of disjunction elimination are evident when
one realises that to prove <span class="math notranslate nohighlight">\(k_1 : P \to R\)</span>, for example, is to assume <span class="math notranslate nohighlight">\(h_1 : P\)</span> and to
deduce <span class="math notranslate nohighlight">\(R\)</span>.</p>
<p>In Lean, given <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">k&#8321;</span> <span class="pre">:</span> <span class="pre">p</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code>, and <code class="docutils literal notranslate"><span class="pre">k&#8322;</span> <span class="pre">:</span> <span class="pre">q</span> <span class="pre">&#8594;</span> <span class="pre">r</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">or.elim</span> <span class="pre">h</span> <span class="pre">k&#8321;</span> <span class="pre">k&#8322;</span></code>
is a proof term for <code class="docutils literal notranslate"><span class="pre">r</span></code>. This considerably shortens the proof of the previous result.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20r%20%3A%20Prop%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20p%20%E2%88%A8%20q)%20(k%E2%82%81%20%3A%20p%20%E2%86%92%20r)%20(k%E2%82%82%20%3A%20q%20%E2%86%92%20r)%20%3A%20r%20%3A%3D%0Aby%20exact%20or.elim%20h%20k%E2%82%81%20k%E2%82%82%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1846.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">(</span><span class="n">k&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">(</span><span class="n">k&#8322;</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8594;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">exact</span> <span class="n">or.elim</span> <span class="n">h</span> <span class="n">k&#8321;</span> <span class="n">k&#8322;</span>
</pre></div>
</div>
</div></div>
<div class="section" id="commutativity-and-associativity-of-disjunction">
<h3><span class="section-number">1.10.3. </span>Commutativity and associativity of disjunction<a class="headerlink" href="#commutativity-and-associativity-of-disjunction" title="Permalink to this headline">&#182;</a></h3>
<p>As a more interesting example, we have a preliminary result on the commutativity of disjunction.</p>
<div class="proof proof-type-theorem" id="id49">
<span id="thm-or-comm1"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.41</span>
        
            <span class="proof-title-name">(Commutativity of disjunction (I))</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(T\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : S \lor T\)</span>, we have <span class="math notranslate nohighlight">\(T \lor S\)</span>.</p>
</div></div><p>We give a proof via backward or elimination and forward or introduction.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By or elimination on <span class="math notranslate nohighlight">\(h\)</span>, it suffices 1. to assume <span class="math notranslate nohighlight">\(h_1 : S\)</span> and deduce
<span class="math notranslate nohighlight">\(T \lor S\)</span> and 2. to assume <span class="math notranslate nohighlight">\(h_2 : T\)</span> and deduce <span class="math notranslate nohighlight">\(T \lor S\)</span>.</p>
<ol class="arabic simple">
<li><p>Assume <span class="math notranslate nohighlight">\(h_1 : S\)</span>. We show <span class="math notranslate nohighlight">\(T\lor S\)</span> by right or introduction on <span class="math notranslate nohighlight">\(h_1\)</span>.</p></li>
<li><p>Assume <span class="math notranslate nohighlight">\(h_2 : T\)</span>. We show <span class="math notranslate nohighlight">\(T\lor S\)</span> by left or introduction on <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
</ol>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20s%20t%20%3A%20Prop%0A%0A--%20BEGIN%0Atheorem%20or_of_or%20(h%20%3A%20s%20%E2%88%A8%20t)%20%3A%20t%20%E2%88%A8%20s%20%3A%3D%0Abegin%0A%20%20cases%20h%20with%20h%E2%82%81%20h%E2%82%82%2C%0A%20%20%7B%20exact%20or.inr%20h%E2%82%81%2C%7D%2C%0A%20%20%7B%20exact%20or.inl%20h%E2%82%82%2C%20%7D%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1878.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">or_of_or</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8744;</span> <span class="n">t</span><span class="o">)</span> <span class="o">:</span> <span class="n">t</span> <span class="bp">&#8744;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inr</span> <span class="n">h&#8321;</span><span class="o">,},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Using the above result, we can prove a more symmetrical version of the commutativity result.</p>
<div class="proof proof-type-theorem" id="id50">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.42</span>
        
            <span class="proof-title-name">(Commutativity of disjunction (II))</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(P \lor Q \leftrightarrow Q\lor P\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By iff introduction, it suffices to prove 1. <span class="math notranslate nohighlight">\(P\lor Q\to Q\lor P\)</span> and 2.
<span class="math notranslate nohighlight">\(Q\lor P\to P\lor Q\)</span>. Both these goals can be closed by applying
<a class="reference internal" href="#thm-or-comm1"><span class="std std-numref">Theorem 1.41</span></a>.</p>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20p%20q%20s%20t%20%3A%20Prop%0A%0Atheorem%20or_of_or%20(h%20%3A%20s%20%E2%88%A8%20t)%20%3A%20t%20%E2%88%A8%20s%20%3A%3D%0Abegin%0A%20%20cases%20h%20with%20h%E2%82%81%20h%E2%82%82%2C%0A%20%20%7B%20exact%20or.inr%20h%E2%82%81%2C%7D%2C%0A%20%20%7B%20show%20t%20%E2%88%A8%20s%2C%20from%20or.inl%20h%E2%82%82%2C%20%7D%2C%0Aend%0Anamespace%20hidden%0A--%20BEGIN%0Atheorem%20or_comm%20%3A%20p%20%E2%88%A8%20q%20%E2%86%94%20q%20%E2%88%A8%20p%20%3A%3D%0Abegin%0A%20%20split%3B%0A%20%20apply%20or_of_or%0Aend%0A--%20END%0Aend%20hidden" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1903.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">or_comm</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span> <span class="bp">&#8596;</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="bp">;</span>
  <span class="n">apply</span> <span class="n">or_of_or</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The associativity result is more involved. We give a partial Lean proof of the result. Fill in
the <code class="docutils literal notranslate"><span class="pre">sorry</span></code> s below to complete the proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20r%20%3A%20Prop%7D%0Anamespace%20hidden%0A--%20BEGIN%0Atheorem%20or_assoc%20%3A%20(p%20%E2%88%A8%20q)%20%E2%88%A8%20r%20%E2%86%94%20p%20%E2%88%A8%20(q%20%E2%88%A8%20r)%20%3A%3D%0Abegin%0A%20%20split%2C%0A%20%20%7B%20intro%20h%2C%0A%20%20%20%20cases%20h%20with%20h%E2%82%81%20h%E2%82%82%2C%0A%20%20%20%20%7B%20cases%20h%E2%82%81%20with%20m%E2%82%81%20m%E2%82%82%2C%0A%20%20%20%20%20%20%7B%20left%2C%20exact%20m%E2%82%81%2C%20%7D%2C%0A%20%20%20%20%20%20%7B%20right%2C%20left%2C%20exact%20m%E2%82%82%2C%20%7D%2C%20%7D%2C%0A%20%20%20%20%7B%20sorry%2C%20%7D%2C%20%7D%2C%0A%20%20%7B%20sorry%2C%20%7D%2C%0Aend%0A--%20END%0Aend%20hidden" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1926.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">or_assoc</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8744;</span> <span class="n">r</span> <span class="bp">&#8596;</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="o">(</span><span class="n">q</span> <span class="bp">&#8744;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">cases</span> <span class="n">h&#8321;</span> <span class="k">with</span> <span class="n">m&#8321;</span> <span class="n">m&#8322;</span><span class="o">,</span>
      <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">m&#8321;</span><span class="o">,</span> <span class="o">},</span>
      <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">m&#8322;</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
    <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="false-and-negation">
<h2><span class="section-number">1.11. </span>False and negation<a class="headerlink" href="#false-and-negation" title="Permalink to this headline">&#182;</a></h2>
<div class="section" id="rules-for-false-and-negation">
<h3><span class="section-number">1.11.1. </span>Rules for false and negation<a class="headerlink" href="#rules-for-false-and-negation" title="Permalink to this headline">&#182;</a></h3>
<p>The symbol <span class="math notranslate nohighlight">\(\bot\)</span>, read &#8216;arbitrary contradiction&#8217; or &#8216;false&#8217; is a constant proposition.
Its use is governed most fundamentally by the principle <em>ex falso sequitur quodlibet</em>, &#8216;out of false,
whatever you like follows&#8217;, also called false elimination.</p>
<p>This principle is illustrated by such English-language phrases as, &#8216;If Torquay United wins the FA Cup,
then I&#8217;m a monkey&#8217;s uncle&#8217;. The premise &#8216;Torquay United wins the FA Cup&#8217; being considered a
contradiction, I can derive anything from its assumption.</p>
<div class="proof proof-type-mathsrule" id="id51">

    <div class="proof-title">
        <span class="proof-type">Rule 1.43</span>
        
            <span class="proof-title-name">(False elimination (<em>ex falso</em>), forward)</span>
        
    </div><div class="proof-content">
<p>Given <span class="math notranslate nohighlight">\(h : \bot\)</span>, we have a proof of <span class="math notranslate nohighlight">\(P\)</span>.</p>
</div></div><div class="proof proof-type-mathsrule" id="id52">

    <div class="proof-title">
        <span class="proof-type">Rule 1.44</span>
        
            <span class="proof-title-name">(False elimination (<em>ex falso</em>), backward)</span>
        
    </div><div class="proof-content">
<p>To prove <span class="math notranslate nohighlight">\(P\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(\bot\)</span>.</p>
</div></div><div class="proof proof-type-example" id="id53">
<span id="ex-neg-elim"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.45</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. We have <span class="math notranslate nohighlight">\((P \to \bot) \to (P \to Q)\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>Assume <span class="math notranslate nohighlight">\(h_1 : P \to bot\)</span>. It suffices to prove <span class="math notranslate nohighlight">\(P \to Q\)</span> (by implication intro.).</p></li>
<li><p>Assume <span class="math notranslate nohighlight">\(h_2 : P\)</span>. It suffice to prove <span class="math notranslate nohighlight">\(Q\)</span> (by implication intro.).</p></li>
<li><p>By false elimination, it suffices to prove <span class="math notranslate nohighlight">\(\bot\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(\bot\)</span> by implication elimination on <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
</ul>
</div></div><p><code class="docutils literal notranslate"><span class="pre">false</span></code> is the Lean equivalent of <span class="math notranslate nohighlight">\(\bot\)</span>. If <code class="docutils literal notranslate"><span class="pre">h</span></code> is a proof term for <code class="docutils literal notranslate"><span class="pre">false</span></code>, then
<code class="docutils literal notranslate"><span class="pre">false.elim</span> <span class="pre">h</span></code> is a proof term for <code class="docutils literal notranslate"><span class="pre">p</span></code> (where <code class="docutils literal notranslate"><span class="pre">p</span></code> is the current goal).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Aexample%20%3A%20(p%20%E2%86%92%20false)%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20p%20%E2%86%92%20false%2C%0A%20%20assume%20h%E2%82%82%20%3A%20p%2C%0A%20%20show%20q%2C%20from%20false.elim%20(h%E2%82%81%20h%E2%82%82)%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_1986.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">false</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">false</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">)</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Alternativly, the tactic <code class="docutils literal notranslate"><span class="pre">exfalso</span></code> can be used to change the current goal to one of proving
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Aexample%20%3A%20(p%20%E2%86%92%20false)%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20p%20%E2%86%92%20false%2C%0A%20%20assume%20h%E2%82%82%20%3A%20p%2C%0A%20%20exfalso%2C%0A%20%20show%20false%2C%20from%20h%E2%82%81%20h%E2%82%82%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2001.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">false</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">false</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We write <span class="math notranslate nohighlight">\(\neg P\)</span> as a shorthand for <span class="math notranslate nohighlight">\(P \to \bot\)</span>. The expression <span class="math notranslate nohighlight">\(\neg P\)</span> is read
&#8216;the negation of <span class="math notranslate nohighlight">\(P\)</span>&#8217; or &#8216;not <span class="math notranslate nohighlight">\(P\)</span>&#8217;. With this notation, we can re-express the above
example.</p>
<div class="proof proof-type-theorem" id="id54">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.46</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h_1 : \neg P\)</span> and <span class="math notranslate nohighlight">\(h_2 : P\)</span>, we
have a proof of <span class="math notranslate nohighlight">\(Q\)</span>.</p>
</div></div><p>This follows on applying <a class="reference internal" href="#ex-neg-elim"><span class="std std-numref">Example 1.45</span></a> with <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20%C2%ACp)%20(h%E2%82%82%20%3A%20p)%20%3A%20q%20%3A%3D%0Abegin%0A%20%20exfalso%2C%0A%20%20show%20false%2C%20from%20h%E2%82%81%20h%E2%82%82%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2025.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Alternatively, the powerful <code class="docutils literal notranslate"><span class="pre">contradiction</span></code> tactic searches the context for a contradition (viz.
the appearance of a proposition and its neagation in the context) and uses it to close the goal.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Aexample%20(h%E2%82%81%20%3A%20%C2%ACp)%20(h%E2%82%82%20%3A%20p)%20%3A%20q%20%3A%3D%0Abegin%0A%20%20contradiction%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2039.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">contradiction</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>In the special case where <span class="math notranslate nohighlight">\(Q\)</span> is <span class="math notranslate nohighlight">\(\bot\)</span>, this result is called <em>false introduction</em> and
is often treated as a rule of inference, though it is really just implication elimination in
disguise.</p>
<div class="proof proof-type-theorem" id="id55">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.47</span>
        
            <span class="proof-title-name">(False introduction, forward)</span>
        
    </div><div class="proof-content">
<p>Given <span class="math notranslate nohighlight">\(h_1 : \neg P\)</span> and <span class="math notranslate nohighlight">\(h_2 : P\)</span>, we have a proof of <span class="math notranslate nohighlight">\(\bot\)</span>.</p>
</div></div><div class="proof proof-type-theorem" id="id56">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.48</span>
        
            <span class="proof-title-name">(False introduction, backward)</span>
        
    </div><div class="proof-content">
<p>Given <span class="math notranslate nohighlight">\(h_1 : \neg P\)</span>, to prove <span class="math notranslate nohighlight">\(\bot\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(P\)</span>.</p>
</div></div><p>Another derived result is negation introduction, which is implication introduction in
disguise.</p>
<div class="proof proof-type-theorem" id="id57">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.49</span>
        
            <span class="proof-title-name">(Negation introduction)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> be a proposition. To prove <span class="math notranslate nohighlight">\(\neg P\)</span> is to assume <span class="math notranslate nohighlight">\(\bot\)</span> and derive
<span class="math notranslate nohighlight">\(P\)</span>.</p>
</div></div></div>
<div class="section" id="applications-of-false-and-negation">
<h3><span class="section-number">1.11.2. </span>Applications of false and negation<a class="headerlink" href="#applications-of-false-and-negation" title="Permalink to this headline">&#182;</a></h3>
<div class="proof proof-type-example" id="id58">

    <div class="proof-title">
        <span class="proof-type">Example 1.50</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h : \neg(P\lor Q)\)</span>, we have <span class="math notranslate nohighlight">\(\neg P\)</span>.</p>
</div></div><p>Here&#8217;s a proof using negation introduction and backward false introduction.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Assume <span class="math notranslate nohighlight">\(h_1 : P\)</span>. By negation introduction, it suffices to derive <span class="math notranslate nohighlight">\(\bot\)</span>.
By false introduction on <span class="math notranslate nohighlight">\(h\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(p \lor q\)</span>. This follows by left
or introduction on <span class="math notranslate nohighlight">\(h_1\)</span>.</p>
</div></div><p>In the Lean proof below, we use <code class="docutils literal notranslate"><span class="pre">apply</span></code> to prove invoke (backward) false introduction, just as we
would when invoking implication elimination. This is because false introduction <em>is</em> implication
elimination.</p>
<p>Likewise, we use <code class="docutils literal notranslate"><span class="pre">assume</span></code> for negation introduction, just as we do for implication introduction.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC(p%20%E2%88%A8%20q))%20%3A%20%C2%ACp%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20p%2C%20%20%20--%20It%20suffices%20to%20prove%20%60false%60.%0A%20%20apply%20h%2C%20%20%20%20%20%20%20%20%20--%20By%20false%20introduction%20on%20%60h%60%2C%20it%20suffices%20to%20prove%20%60p%20%E2%88%A8%20q%60.%0A%20%20exact%20or.inl%20h%E2%82%81%2C%20--%20This%20follows%20by%20left%20or%20introduction%20on%20%60h%E2%82%81%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2090.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">))</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>   <span class="c1">-- It suffices to prove `false`.</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>         <span class="c1">-- By false introduction on `h`, it suffices to prove `p &#8744; q`.</span>
  <span class="n">exact</span> <span class="n">or.inl</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="c1">-- This follows by left or introduction on `h&#8321;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The next example shows one can derive the implication <span class="math notranslate nohighlight">\(P\to Q\)</span> given the hypothesis
<span class="math notranslate nohighlight">\(\neg P \lor Q\)</span>. We&#8217;ll later show the converse of this assertion.</p>
<div class="proof proof-type-example" id="id59">

    <div class="proof-title">
        <span class="proof-type">Example 1.51</span>
        
            <span class="proof-title-name">(One direction of material conditional)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(\neg P \lor Q \to (P\to Q)\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Assume <span class="math notranslate nohighlight">\(h_1 : \neg P\lor Q\)</span>. Assume <span class="math notranslate nohighlight">\(h_2 : P\)</span>. It suffices to prove <span class="math notranslate nohighlight">\(Q\)</span>.
By or elimination on <span class="math notranslate nohighlight">\(h_1\)</span>, it suffices to 1. assume <span class="math notranslate nohighlight">\(h_3 : \neg P\)</span> and derive
<span class="math notranslate nohighlight">\(Q\)</span> and 2. assume <span class="math notranslate nohighlight">\(h_4 : Q\)</span> and derive <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<ol class="arabic simple">
<li><p>Assume <span class="math notranslate nohighlight">\(h_3 : \neg P\)</span>. By false elimination, it suffices to prove <span class="math notranslate nohighlight">\(\bot\)</span>. We show this by
false introduction on <span class="math notranslate nohighlight">\(h_3\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
<li><p>Assume <span class="math notranslate nohighlight">\(h_4 : Q\)</span>. We show <span class="math notranslate nohighlight">\(Q\)</span> by reiteration on <span class="math notranslate nohighlight">\(h_4\)</span>.</p></li>
</ol>
</div></div><p>In the Lean proof below we write <code class="docutils literal notranslate"><span class="pre">h&#8323;</span> <span class="pre">h&#8322;</span></code> for a forward false introduction using <code class="docutils literal notranslate"><span class="pre">h&#8323;</span></code> and <code class="docutils literal notranslate"><span class="pre">h&#8322;</span></code>.
This is because we are really doing implication elimination on <code class="docutils literal notranslate"><span class="pre">h&#8323;</span></code> and <code class="docutils literal notranslate"><span class="pre">h&#8322;</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Aexample%20%3A%20(%C2%ACp%20%E2%88%A8%20q)%20%E2%86%92%20(p%20%E2%86%92%20q)%20%3A%3D%0Abegin%0A%20%20intros%20h%E2%82%81%20h%E2%82%82%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%ACp%20%E2%88%A8%20q%60.%20Assume%20%60h%E2%82%82%20%3A%20p%60.%20It%20suffices%20to%20prove%20%60q%60.%0A%20%20--%20By%20or%20elim.%20on%20%60h%E2%82%81%60%2C%20it%20suffices%20to%201.%20assume%20%60h%E2%82%83%20%3A%20%C2%ACp%60%20and%20derive%20%60q%60%20and%202.%20assume%20%60h%E2%82%84%20%3A%20q%60%20and%20derive%20%60q%60%0A%20%20cases%20h%E2%82%81%20with%20h%E2%82%83%20h%E2%82%84%2C%0A%20%20%7B%20exfalso%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20false%20elimination%2C%20it%20suffices%20to%20prove%20%60false%60.%0A%20%20%20%20show%20false%2C%20from%20h%E2%82%83%20h%E2%82%82%2C%20%7D%2C%20%20--%20We%20show%20false%20by%20false%20introduction%20on%20%60h%E2%82%83%60%20and%20%60h%E2%82%82%60.%0A%20%20%7B%20show%20q%2C%20from%20h%E2%82%84%2C%20%7D%2C%20%20%20%20%20%20%20%20%20--%20We%20show%20%60q%60%20by%20reiteration%20on%20%60h%E2%82%84%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2123.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span>                  <span class="c1">-- Assume `h&#8321; : &#172;p &#8744; q`. Assume `h&#8322; : p`. It suffices to prove `q`.</span>
  <span class="c1">-- By or elim. on `h&#8321;`, it suffices to 1. assume `h&#8323; : &#172;p` and derive `q` and 2. assume `h&#8324; : q` and derive `q`</span>
  <span class="n">cases</span> <span class="n">h&#8321;</span> <span class="k">with</span> <span class="n">h&#8323;</span> <span class="n">h&#8324;</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>                    <span class="c1">-- By false elimination, it suffices to prove `false`.</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8323;</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="o">},</span>  <span class="c1">-- We show false by false introduction on `h&#8323;` and `h&#8322;`.</span>
  <span class="o">{</span> <span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8324;</span><span class="o">,</span> <span class="o">},</span>         <span class="c1">-- We show `q` by reiteration on `h&#8324;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The next result is one half of a result that shows <span class="math notranslate nohighlight">\(P\)</span> is equivalent to <span class="math notranslate nohighlight">\(\neg\neg P\)</span>.
We prove the other half of this result in <a class="reference internal" href="#sec-classical-reasoning"><span class="std std-numref">Section 1.12</span></a>.</p>
<div class="proof proof-type-theorem" id="id60">
<span id="thm-not-not-of-self"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.52</span>
        
            <span class="proof-title-name">(One direction of double negation)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> be a proposition. We have <span class="math notranslate nohighlight">\(P\to\neg\neg P\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<ul class="simple">
<li><p>Assume <span class="math notranslate nohighlight">\(h_1 : P\)</span>. It suffices to prove <span class="math notranslate nohighlight">\(\neg\neg P\)</span>.</p></li>
<li><p>Assume <span class="math notranslate nohighlight">\(h_2 : \neg P\)</span>. By negation introduction, it suffices to prove <span class="math notranslate nohighlight">\(\bot\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\(\bot\)</span> by false introduction on <span class="math notranslate nohighlight">\(h_2\)</span> and <span class="math notranslate nohighlight">\(h_1\)</span>.</p></li>
</ul>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20p%20%3A%20Prop%0A--%20BEGIN%0Atheorem%20not_not_of_self%20%3A%20p%20%E2%86%92%20%C2%AC%C2%ACp%20%3A%3D%0Abegin%0A%20%20intros%20h%E2%82%81%20h%E2%82%82%2C%20%20%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%E2%82%81%20%3A%20p%60.%20Assume%20%60h%E2%82%82%20%3A%20%C2%ACp%60.%20It%20suffices%20to%20prove%20%60false%60.%0A%20%20show%20false%2C%20from%20h%E2%82%82%20h%E2%82%81%2C%20--%20We%20show%20%60false%60%20by%20false%20introduction%20on%20%60h%E2%82%82%60%20and%20%60h%E2%82%81%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2155.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_not_of_self</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8594;</span> <span class="bp">&#172;&#172;</span><span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span>           <span class="c1">-- Assume `h&#8321; : p`. Assume `h&#8322; : &#172;p`. It suffices to prove `false`.</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8322;</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="c1">-- We show `false` by false introduction on `h&#8322;` and `h&#8321;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The contrapositive of a conditional <span class="math notranslate nohighlight">\(P\to Q\)</span> is the proposition <span class="math notranslate nohighlight">\(\neg Q\to\neg P\)</span>.
In <a class="reference internal" href="#sec-classical-reasoning"><span class="std std-numref">Section 1.12</span></a>, we&#8217;ll prove that a proposition is equivalent to
its contrapositive. We&#8217;ll prove one half of that assertion now.</p>
<div class="proof proof-type-theorem" id="id61">
<span id="thm-mt"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.53</span>
        
            <span class="proof-title-name">(One direction of contrapositive theorem, <em>modus tollens</em>)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\((P\to Q)\to(\neg Q\to\neg P)\)</span>.</p>
</div></div><p>We give the Lean proof below with the corresponding mathematical proof in the comments.
Note I could have replaced the first two lines with a single line, <code class="docutils literal notranslate"><span class="pre">intros</span> <span class="pre">h&#8321;</span> <span class="pre">h&#8322;</span> <span class="pre">h&#8323;</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Atheorem%20mt%20%3A%20(p%20%E2%86%92%20q)%20%E2%86%92%20(%C2%ACq%20%E2%86%92%20%C2%ACp)%20%3A%3D%0Abegin%0A%20%20intros%20h%E2%82%81%20h%E2%82%82%2C%20--%20Assume%20%60h%E2%82%81%20%3A%20p%20%E2%86%92%20q%60%2C%20%60h%E2%82%82%20%3A%20%C2%ACq%60.%20It%20suffices%20to%20prove%20%60%C2%ACp%60.%0A%20%20intro%20h%E2%82%83%2C%20%20%20%20%20--%20Assume%20%60h%E2%82%83%20%3A%20p%60.%20By%20negation%20introiduction%2C%20it%20suffices%20to%20prove%20%60false%60.%0A%20%20apply%20h%E2%82%82%2C%20%20%20%20%20--%20By%20fale%20introduction%20on%20%60h%E2%82%82%60%2C%20it%20suffices%20to%20prove%20%60q%60.%0A%20%20exact%20h%E2%82%81%20h%E2%82%83%2C%20%20--%20This%20follows%20by%20implication%20elimination%20on%20%60h%E2%82%81%60%20and%20%60h%E2%82%83%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2179.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">mt</span> <span class="o">:</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="c1">-- Assume `h&#8321; : p &#8594; q`, `h&#8322; : &#172;q`. It suffices to prove `&#172;p`.</span>
  <span class="n">intro</span> <span class="n">h&#8323;</span><span class="o">,</span>     <span class="c1">-- Assume `h&#8323; : p`. By negation introiduction, it suffices to prove `false`.</span>
  <span class="n">apply</span> <span class="n">h&#8322;</span><span class="o">,</span>     <span class="c1">-- By fale introduction on `h&#8322;`, it suffices to prove `q`.</span>
  <span class="n">exact</span> <span class="n">h&#8321;</span> <span class="n">h&#8323;</span><span class="o">,</span>  <span class="c1">-- This follows by implication elimination on `h&#8321;` and `h&#8323;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>De Morgan&#8217;s laws state 1. <span class="math notranslate nohighlight">\(\neg(P \land Q)\leftrightarrow\neg P\lor \neg Q\)</span> and 2.
<span class="math notranslate nohighlight">\(\neg(P\lor Q)\leftrightarrow\neg P \land \neg Q\)</span>.</p>
<p>In total, there are four directions to prove. We give proofs of three directions in this section
and the remaining direction in <a class="reference internal" href="#sec-classical-reasoning"><span class="std std-numref">Section 1.12</span></a>.</p>
<div class="proof proof-type-theorem" id="id62">
<span id="thm-not-or-of-not-and-not"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.54</span>
        
            <span class="proof-title-name">(De Morgan, &#8216;not or of not and not&#8217;)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(\neg P \land\neg Q\to\neg(P\lor Q)\)</span>.</p>
</div></div><p>Our first proof uses each rule of inference explicitly.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Atheorem%20not_or_of_not_and_not%20%3A%20%C2%ACp%20%E2%88%A7%20%C2%ACq%20%E2%86%92%20%20%C2%AC(p%20%E2%88%A8%20q)%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20%C2%ACp%20%E2%88%A7%20%C2%ACq%2C%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%ACp%20%E2%88%A7%20%C2%ACq%60.%20By%20implication%20introduction%2C%20it%20suffices%20to%20prove%20%60%C2%AC(p%20%E2%88%A8%20q)%60.%0A%20%20cases%20h%E2%82%81%20with%20h%E2%82%83%20h%E2%82%84%2C%20--%20We%20have%20%60h%E2%82%83%20%3A%20%C2%ACp%60%20and%20%60h%E2%82%84%20%3A%20%C2%ACq%60%20by%20left%20and%20right%20%60%E2%88%A7%60%20elim.%20on%20%60h%E2%82%81%60.%0A%20%20assume%20h%E2%82%85%20%3A%20p%20%E2%88%A8%20q%2C%20%20%20--%20Assume%20%60h%E2%82%85%20%3A%20p%20%E2%88%A8%20q%60.%20By%20negation%20introduction%2C%20it%20suffices%20to%20prove%20%60false%60.%0A%20%20--%20By%20or%20elimination%20on%20%60h%E2%82%85%60%2C%20it%20suffices%20to%201.%20assume%20%60h%E2%82%86%20%3A%20p%60%20and%20derive%20%60false%60%20and%202.%20assume%20%60h%E2%82%87%20%3A%20q%60%20and%20derive%20%60false%60.%0A%20%20cases%20h%E2%82%85%20with%20h%E2%82%86%20h%E2%82%87%2C%0A%20%20%7B%20exact%20h%E2%82%83%20h%E2%82%86%2C%20%7D%2C%20%20%20%20--%20The%20goal%20in%20the%20first%20case%20is%20closed%20by%20false%20introduction%20on%20%60h%E2%82%83%60%20and%20%60h%E2%82%86%60.%0A%20%20%7B%20exact%20h%E2%82%84%20h%E2%82%87%2C%20%7D%2C%20%20%20%20--%20The%20goal%20in%20the%20second%20case%20is%20closed%20by%20false%20introduction%20on%20%60h%E2%82%84%60%20and%20%60h%E2%82%87%60.%0A%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2206.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_or_of_not_and_not</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span>  <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">,</span> <span class="c1">-- Assume `h&#8321; : &#172;p &#8743; &#172;q`. By implication introduction, it suffices to prove `&#172;(p &#8744; q)`.</span>
  <span class="n">cases</span> <span class="n">h&#8321;</span> <span class="k">with</span> <span class="n">h&#8323;</span> <span class="n">h&#8324;</span><span class="o">,</span> <span class="c1">-- We have `h&#8323; : &#172;p` and `h&#8324; : &#172;q` by left and right `&#8743;` elim. on `h&#8321;`.</span>
  <span class="k">assume</span> <span class="n">h&#8325;</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">,</span>   <span class="c1">-- Assume `h&#8325; : p &#8744; q`. By negation introduction, it suffices to prove `false`.</span>
  <span class="c1">-- By or elimination on `h&#8325;`, it suffices to 1. assume `h&#8326; : p` and derive `false` and 2. assume `h&#8327; : q` and derive `false`.</span>
  <span class="n">cases</span> <span class="n">h&#8325;</span> <span class="k">with</span> <span class="n">h&#8326;</span> <span class="n">h&#8327;</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#8323;</span> <span class="n">h&#8326;</span><span class="o">,</span> <span class="o">},</span>    <span class="c1">-- The goal in the first case is closed by false introduction on `h&#8323;` and `h&#8326;`.</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#8324;</span> <span class="n">h&#8327;</span><span class="o">,</span> <span class="o">},</span>    <span class="c1">-- The goal in the second case is closed by false introduction on `h&#8324;` and `h&#8327;`.</span>

<span class="kd">end</span>
</pre></div>
</div>
</div><p>The second proof greatly simplifies this by using the <code class="docutils literal notranslate"><span class="pre">rintro</span></code> tactic, which introduces an
assumption and decomposes it recursively. That is, it applies <code class="docutils literal notranslate"><span class="pre">cases</span></code> recursively to each
introduced hypothesis.</p>
<p>Note the differences in how we use <code class="docutils literal notranslate"><span class="pre">rintro</span></code>. In our first application, we use <code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">&#10216;h&#8323;,</span> <span class="pre">h&#8324;&#10217;</span></code>
to introduce and decompose a hypothesis representing the conjunction <code class="docutils literal notranslate"><span class="pre">&#172;p</span> <span class="pre">&#8743;</span> <span class="pre">&#172;q</span></code>.
The anonymous-constructor-like notation <code class="docutils literal notranslate"><span class="pre">&#10216;h&#8323;,</span> <span class="pre">h&#8324;&#10217;</span></code> appears here because the conjunction connective
has one constructor, <code class="docutils literal notranslate"><span class="pre">and.intro</span></code>. The decomposition introduces <code class="docutils literal notranslate"><span class="pre">h&#8323;</span> <span class="pre">:</span> <span class="pre">&#172;p</span></code> and <code class="docutils literal notranslate"><span class="pre">h&#8324;</span> <span class="pre">:</span> <span class="pre">&#172;q</span></code> into
the context.</p>
<p>We next use <code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">(h&#8326;</span> <span class="pre">|</span> <span class="pre">h&#8327;)</span></code> to introduce and decompose a hypothesis representing the
disjuction <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">&#8744;</span> <span class="pre">q</span></code>. As disjunction has two constructors, <code class="docutils literal notranslate"><span class="pre">or.inl</span></code> and <code class="docutils literal notranslate"><span class="pre">or.inr</span></code>, the
decomposition introduces <em>two</em> new goals. This corresponds to or elimination.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.rcases%0Avariables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Atheorem%20not_or_of_not_and_not%20%3A%20%C2%ACp%20%E2%88%A7%20%C2%ACq%20%E2%86%92%20%20%C2%AC(p%20%E2%88%A8%20q)%20%3A%3D%0Abegin%0A%20%20rintro%20%E2%9F%A8h%E2%82%83%2C%20h%E2%82%84%E2%9F%A9%2C%20%20%20--%20By%20%60%E2%86%92%60%20intro%20and%20left%20and%20right%20%60%E2%88%A7%60%20elim%2C%20we%20have%20%60h%E2%82%83%20%3A%20%C2%ACp%60%20and%20%60h%E2%82%84%20%3A%20%C2%ACq%60.%0A%20%20--%20By%20%60%E2%86%92%60%20intro%20and%20or%20elim.%2C%20it%20suffices%20to%201.%20assume%20%60h%E2%82%86%20%3A%20p%60%20and%20derive%20%60false%60%20and%202.%20assume%20%60h%E2%82%87%20%3A%20q%60%20and%20derive%20%60false%60.%0A%20%20rintro%20(h%E2%82%86%20%7C%20h%E2%82%87)%2C%0A%20%20%7B%20exact%20h%E2%82%83%20h%E2%82%86%2C%20%7D%2C%20--%20The%20goal%20in%20the%20first%20case%20is%20closed%20by%20false%20introduction%20on%20%60h%E2%82%83%60%20and%20%60h%E2%82%86%60.%0A%20%20%7B%20exact%20h%E2%82%84%20h%E2%82%87%2C%20%7D%2C%20--%20The%20goal%20in%20the%20second%20case%20is%20closed%20by%20false%20introduction%20on%20%60h%E2%82%84%60%20and%20%60h%E2%82%87%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2237.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_or_of_not_and_not</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span>  <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">&#10216;</span><span class="n">h&#8323;</span><span class="o">,</span> <span class="n">h&#8324;</span><span class="o">&#10217;,</span>   <span class="c1">-- By `&#8594;` intro and left and right `&#8743;` elim, we have `h&#8323; : &#172;p` and `h&#8324; : &#172;q`.</span>
  <span class="c1">-- By `&#8594;` intro and or elim., it suffices to 1. assume `h&#8326; : p` and derive `false` and 2. assume `h&#8327; : q` and derive `false`.</span>
  <span class="n">rintro</span> <span class="o">(</span><span class="n">h&#8326;</span> <span class="bp">|</span> <span class="n">h&#8327;</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#8323;</span> <span class="n">h&#8326;</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- The goal in the first case is closed by false introduction on `h&#8323;` and `h&#8326;`.</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#8324;</span> <span class="n">h&#8327;</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- The goal in the second case is closed by false introduction on `h&#8324;` and `h&#8327;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Several successive <code class="docutils literal notranslate"><span class="pre">rintro</span></code> lines can be combined, albeit with some loss of readability.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.rcases%0Avariables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Atheorem%20not_or_of_not_and_not%20%3A%20%C2%ACp%20%E2%88%A7%20%C2%ACq%20%E2%86%92%20%20%C2%AC(p%20%E2%88%A8%20q)%20%3A%3D%0Abegin%0A%20%20rintro%20%E2%9F%A8h%E2%82%83%2C%20h%E2%82%84%E2%9F%A9%20(h%E2%82%86%20%7C%20h%E2%82%87)%2C%0A%20%20%7B%20exact%20h%E2%82%83%20h%E2%82%86%2C%20%7D%2C%20--%20The%20goal%20in%20the%20first%20case%20is%20closed%20by%20false%20introduction%20on%20%60h%E2%82%83%60%20and%20%60h%E2%82%86%60.%0A%20%20%7B%20exact%20h%E2%82%84%20h%E2%82%87%2C%20%7D%2C%20--%20The%20goal%20in%20the%20second%20case%20is%20closed%20by%20false%20introduction%20on%20%60h%E2%82%84%60%20and%20%60h%E2%82%87%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2254.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_or_of_not_and_not</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span>  <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">&#10216;</span><span class="n">h&#8323;</span><span class="o">,</span> <span class="n">h&#8324;</span><span class="o">&#10217;</span> <span class="o">(</span><span class="n">h&#8326;</span> <span class="bp">|</span> <span class="n">h&#8327;</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#8323;</span> <span class="n">h&#8326;</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- The goal in the first case is closed by false introduction on `h&#8323;` and `h&#8326;`.</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#8324;</span> <span class="n">h&#8327;</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- The goal in the second case is closed by false introduction on `h&#8324;` and `h&#8327;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><div class="proof proof-type-theorem" id="id63">
<span id="thm-not-and-not-of-not-or"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.55</span>
        
            <span class="proof-title-name">(De Morgan, &#8216;not and not of not or&#8217;)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(\neg(P\lor Q)\to\neg P\land\neg Q\)</span>.</p>
</div></div><p>Here is a partial Lean proof. Fill in the <code class="docutils literal notranslate"><span class="pre">sorry</span></code> s. Hint: you&#8217;ve already seen the proof of the
first subgoal earlier in this section.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A%0A--%20BEGIN%0Atheorem%20not_and_not_of_not_or%20%3A%20%C2%AC(p%20%E2%88%A8%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A7%20%C2%ACq%20%3A%3D%0Abegin%0A%20%20intro%20h%E2%82%81%2C%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%AC(p%20%E2%88%A8%20q)%60.%20It%20suffices%20to%20prove%20%60%C2%ACp%20%E2%88%A7%20%C2%ACq%60.%0A%20%20split%2C%20%20%20%20--%20By%20and%20introduction%2C%20it%20suffices%20to%20prove%201.%20%60%C2%ACp%60%20and%202.%20%60%C2%ACq%60.%0A%20%20%7B%20sorry%20%7D%2C%0A%20%20%7B%20sorry%20%7D%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2276.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_and_not_of_not_or</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="c1">-- Assume `h&#8321; : &#172;(p &#8744; q)`. It suffices to prove `&#172;p &#8743; &#172;q`.</span>
  <span class="n">split</span><span class="o">,</span>    <span class="c1">-- By and introduction, it suffices to prove 1. `&#172;p` and 2. `&#172;q`.</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>By iff introduction on <a class="reference internal" href="#thm-not-or-of-not-and-not"><span class="std std-numref">Theorem 1.54</span></a> and
<a class="reference internal" href="#thm-not-and-not-of-not-or"><span class="std std-numref">Theorem 1.55</span></a>, we have our first complete De Morgan&#8217;s law.</p>
<div class="proof proof-type-theorem" id="id64">
<span id="thm-not-or-distrib"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.56</span>
        
            <span class="proof-title-name">(De Morgan, &#8216;not or distrib&#8217;)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then
<span class="math notranslate nohighlight">\(\neg(P\lor Q)\leftrightarrow\neg P\land\neg Q\)</span>.</p>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0Atheorem%20not_and_not_of_not_or%20%3A%20%C2%AC(p%20%E2%88%A8%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A7%20%C2%ACq%20%3A%3D%0A%CE%BB%20hnpq%2C%20%E2%9F%A8%20%CE%BB%20hp%2C%20hnpq%20(or.inl%20hp)%20%2C%20%CE%BB%20hq%2C%20hnpq%20(or.inr%20hq)%20%E2%9F%A9%0Atheorem%20not_or_of_not_and_not%20%3A%20%C2%ACp%20%E2%88%A7%20%C2%ACq%20%E2%86%92%20%C2%AC(p%20%E2%88%A8%20q)%20%3A%3D%0A%CE%BB%20hnphq%20hpq%2C%20or.elim%20hpq%20(%CE%BB%20hp%2C%20hnphq.1%20hp)%20(%CE%BB%20hq%2C%20hnphq.2%20hq)%0A--%20BEGIN%0Atheorem%20not_or_distrib%20%3A%20%C2%AC(p%20%E2%88%A8%20q)%20%E2%86%94%20%C2%ACp%20%E2%88%A7%20%C2%AC%20q%20%3A%3D%0Abegin%0A%20%20split%2C%0A%20%20%7B%20exact%20not_and_not_of_not_or%2C%20%7D%2C%0A%20%20%7B%20exact%20not_or_of_not_and_not%2C%20%7D%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2301.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_or_distrib</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">not_and_not_of_not_or</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">not_or_of_not_and_not</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><div class="proof proof-type-theorem" id="id65">
<span id="thm-not-and-of-not-or-not"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.57</span>
        
            <span class="proof-title-name">(De Morgan, &#8216;not and of not or not&#8217;)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(\neg P \lor\neg Q\to\neg(P\land Q)\)</span>.</p>
</div></div><p>Here&#8217;s part of the Lean proof. Fill in the <code class="docutils literal notranslate"><span class="pre">sorry</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic.rcases%0Avariables%20%7Bp%20q%20%3A%20Prop%7D%0Anamespace%20hidden%0A--%20BEGIN%0Atheorem%20not_and_of_not_or_not%20%3A%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20%E2%86%92%20%C2%AC(p%20%E2%88%A7%20q)%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20%C2%ACp%20%E2%88%A8%20%C2%ACq%2C%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%ACp%20%E2%88%A8%20%C2%ACq%60.%20It%20suffices%20to%20prove%20%60%C2%AC(p%20%E2%88%A7%20q)%60.%0A%20%20rintro%20%E2%9F%A8h%E2%82%82%2C%20h%E2%82%83%E2%9F%A9%2C%20%20%20%20%20%20--%20Introduce%20%60p%20%E2%88%A7%20q%60.%20By%20and%20elim.%2C%20%60h%E2%82%82%20%3A%20p%60%20and%20%60h%E2%82%83%20%3A%20q%60.%20By%20neg.%20intro%2C%20it%20suffices%20to%20prove%20%60false%60.%0A%20%20--%20By%20or%20elim.%20on%20%60h%E2%82%81%60%2C%20it%20suffices%20to%201.%20assume%20%60h%E2%82%84%20%3A%20%C2%ACp%60%20and%20prove%20%60false%60%20and%202.%20assume%20%60h%E2%82%85%20%3A%20%C2%ACq%60%20and%20prove%20%60false%60.%0A%20%20cases%20h%E2%82%81%20with%20h%E2%82%84%20h%E2%82%85%2C%0A%20%20%7B%20exact%20h%E2%82%84%20h%E2%82%82%2C%20%7D%2C%20--%20This%20follows%20by%20negation%20introduction%20on%20%60h%E2%82%81%60%20and%20%60h%E2%82%83%60.%0A%20%20%7B%20sorry%20%7D%2C%0Aend%0A--%20END%0Aend%20hidden" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2327.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_and_of_not_or_not</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">,</span> <span class="c1">-- Assume `h&#8321; : &#172;p &#8744; &#172;q`. It suffices to prove `&#172;(p &#8743; q)`.</span>
  <span class="n">rintro</span> <span class="o">&#10216;</span><span class="n">h&#8322;</span><span class="o">,</span> <span class="n">h&#8323;</span><span class="o">&#10217;,</span>      <span class="c1">-- Introduce `p &#8743; q`. By and elim., `h&#8322; : p` and `h&#8323; : q`. By neg. intro, it suffices to prove `false`.</span>
  <span class="c1">-- By or elim. on `h&#8321;`, it suffices to 1. assume `h&#8324; : &#172;p` and prove `false` and 2. assume `h&#8325; : &#172;q` and prove `false`.</span>
  <span class="n">cases</span> <span class="n">h&#8321;</span> <span class="k">with</span> <span class="n">h&#8324;</span> <span class="n">h&#8325;</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#8324;</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- This follows by negation introduction on `h&#8321;` and `h&#8323;`.</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>
<div class="section" id="classical-reasoning">
<span id="sec-classical-reasoning"></span><h2><span class="section-number">1.12. </span>Classical reasoning<a class="headerlink" href="#classical-reasoning" title="Permalink to this headline">&#182;</a></h2>
<div class="section" id="intuitionistic-and-constructive-reasoning">
<h3><span class="section-number">1.12.1. </span>Intuitionistic and constructive reasoning<a class="headerlink" href="#intuitionistic-and-constructive-reasoning" title="Permalink to this headline">&#182;</a></h3>
<p>You&#8217;ve now seen all the rules of inference for &#8216;intuitionistic&#8217; propositional logic.
Congratulations! Intuitionistic logic (more generally &#8216;constructive reasoning&#8217;) is a form of
reasoning first investigated by L. E. J. Brouwer in the early 20th century.</p>
<p>From a constructive proof of a theorem, one can extract a method for constructing the described
mathematical object. Almost all school mathematics is constructive.</p>
<p>For example, in school you prove that every quadratic equation <span class="math notranslate nohighlight">\(ax^2 + bx  +c = 0\)</span>, where
<span class="math notranslate nohighlight">\(a, b, c\)</span> are real (or complex) numbers with <span class="math notranslate nohighlight">\(a\ne0\)</span>, has a (real or complex) solution</p>
<div class="math notranslate nohighlight">
\[\frac{-b + \sqrt{a^2-4ac}}{2a}.\]</div>
<p>This is an explicit construction of a root of the quadratic. Can you conceive of a proof of
existence that <em>doesn&#8217;t</em> involve the construction of a root?</p>
<p>For a more elementary example, let <span class="math notranslate nohighlight">\(P\)</span> be a proposition. Can you prove <span class="math notranslate nohighlight">\(P \lor \neg P\)</span>?
Using constructive reasoning you can&#8217;t. In general, a constructive proof of <span class="math notranslate nohighlight">\(A \lor B\)</span>
requires that you prove <span class="math notranslate nohighlight">\(A\)</span> or that you prove <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>A mathematician using constructive reasoning will not be able to say, &#8216;The Queen likes tea or the
Queen doesn&#8217;t like tea&#8217; unless they can prove either that the Queen likes tea or that the Queen
doesn&#8217;t like tea.</p>
</div>
<div class="section" id="the-law-of-the-excluded-middle">
<h3><span class="section-number">1.12.2. </span>The law of the excluded middle<a class="headerlink" href="#the-law-of-the-excluded-middle" title="Permalink to this headline">&#182;</a></h3>
<p>To resolve this issue, &#8216;classical reasoning&#8217; takes <span class="math notranslate nohighlight">\(P\lor\neg P\)</span> as an axiom <a class="footnote-reference brackets" href="#id7" id="id6">2</a>, called the
law of the excluded middle.</p>
<div class="proof proof-type-axiom" id="id66">

    <div class="proof-title">
        <span class="proof-type">Axiom 1.58</span>
        
            <span class="proof-title-name">(Law of the excluded middle)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> be a proposition. Then we have a proof of <span class="math notranslate nohighlight">\(P\lor\neg P\)</span>.</p>
</div></div><p>A mathematician using this law can deduce, &#8216;The Queen likes tea or the Queen doesn&#8217;t like tea&#8217;,
without any knowledge of the Queen&#8217;s beverage preferences.</p>
<p>In Lean, the law of the excluded middle is a theorem called <code class="docutils literal notranslate"><span class="pre">classical.em</span></code>. Here&#8217;s a very short
example in which we prove <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&#8744;</span> <span class="pre">&#172;q</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bq%20%3A%20Prop%7D%0A--%20BEGIN%0Aexample%20%3A%20q%20%E2%88%A8%20%C2%ACq%20%3A%3D%20classical.em%20q%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2394.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="o">:=</span> <span class="n">classical.em</span> <span class="n">q</span>
</pre></div>
</div>
</div><p>We&#8217;ll give a proof of the result below, using the law of the excluded middle. The proof needs
elements of predicate logic together with results on even and odd numbers. We will cover this
in-depth in <a class="reference internal" href="pred_logic.html#sec-pred-logic"><span class="std std-numref">Section 3</span></a>.</p>
<div class="proof proof-type-example" id="id67">
<span id="ex-x-xplus3-even"></span>
    <div class="proof-title">
        <span class="proof-type">Example 1.59</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(x\)</span> be an integer. Then <span class="math notranslate nohighlight">\(x(x+3)\)</span> is even.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By definition of &#8216;even&#8217;, our goal is to prove that there exists an integer <span class="math notranslate nohighlight">\(m\)</span> such that
<span class="math notranslate nohighlight">\(x(x+3)=2m\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(P\)</span> denote &#8216;<span class="math notranslate nohighlight">\(x\)</span> is even&#8217;. By the law of the excluded middle, applied to <span class="math notranslate nohighlight">\(P\)</span>,
we have <span class="math notranslate nohighlight">\(h_1 : P\lor\neg P\)</span>.</p>
<p>By or elimination on <span class="math notranslate nohighlight">\(h_1\)</span>, it suffices to 1. assume <span class="math notranslate nohighlight">\(h_2 : P\)</span> and derive the goal
and 2. assume <span class="math notranslate nohighlight">\(h_3 : \neg P\)</span> and derive the goal.</p>
<p>1. Assume <span class="math notranslate nohighlight">\(h_2 : P\)</span>. That is, <span class="math notranslate nohighlight">\(x\)</span> is even. By definition, there exists an integer
<span class="math notranslate nohighlight">\(k\)</span> such that <span class="math notranslate nohighlight">\(x = 2k\)</span>. Assume <span class="math notranslate nohighlight">\(k\)</span> is an integer for which <span class="math notranslate nohighlight">\(x = 2k\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[x(x+3) = 2k(x+3) = 2(k(x+3)).\]</div>
<p>Take <span class="math notranslate nohighlight">\(m := k(x+3)\)</span>. Then there is an integer <span class="math notranslate nohighlight">\(m\)</span> such that <span class="math notranslate nohighlight">\(x(x+3)=2m\)</span>.</p>
<p>2. Assume <span class="math notranslate nohighlight">\(h_3 : \neg P\)</span>. That is, <span class="math notranslate nohighlight">\(x\)</span> is not even. Thus (why?) <span class="math notranslate nohighlight">\(x\)</span> is odd.
So there is an integer <span class="math notranslate nohighlight">\(k\)</span> such that <span class="math notranslate nohighlight">\(x = 2k + 1\)</span>. Assume <span class="math notranslate nohighlight">\(k\)</span> is an integer
for which <span class="math notranslate nohighlight">\(x = 2k+1\)</span>. Then <span class="math notranslate nohighlight">\(x+3 = (2k+1)+3=2(k+2)\)</span>.
We deduce</p>
<div class="math notranslate nohighlight">
\[x(x+3) = x\times(2(k+2)) = 2(x(k+2)).\]</div>
<p>Take <span class="math notranslate nohighlight">\(m := x(k+2)\)</span>. Then there is an integer <span class="math notranslate nohighlight">\(m\)</span> such that <span class="math notranslate nohighlight">\(x(x+3)=2m\)</span>.</p>
<p>This completes the proof.</p>
</div></div><dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id6">2</a></span></dt>
<dd><p>Technically,many systems that use classical reasoning, including Lean, assume the
<em>axiom of choice</em>, a rather more sophisticated statement, and use it to deduce the law of the
excluded middle.</p>
</dd>
</dl>
</div>
<div class="section" id="proof-by-cases">
<h3><span class="section-number">1.12.3. </span>Proof by cases<a class="headerlink" href="#proof-by-cases" title="Permalink to this headline">&#182;</a></h3>
<p><a class="reference internal" href="#ex-x-xplus3-even"><span class="std std-numref">Example 1.59</span></a> is an instance of a method of proof called <em>proof by cases</em>.
Below, give a proof of the general proof method.</p>
<div class="proof proof-type-theorem" id="id68">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.60</span>
        
            <span class="proof-title-name">(Proof by cases)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be propositions. Given <span class="math notranslate nohighlight">\(h_1 : A \to B\)</span> and
<span class="math notranslate nohighlight">\(h_2 : \neg A \to B\)</span>, we have a proof of <span class="math notranslate nohighlight">\(B\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By the law of the excluded middle, applied to <span class="math notranslate nohighlight">\(A\)</span>, we have <span class="math notranslate nohighlight">\(h : A \lor \neg A\)</span>.
By or elimination applied to <span class="math notranslate nohighlight">\(h\)</span>, to prove <span class="math notranslate nohighlight">\(B\)</span>, it suffices to
1. assume <span class="math notranslate nohighlight">\(k_1 : A\)</span> and derive <span class="math notranslate nohighlight">\(B\)</span> and 2. assume <span class="math notranslate nohighlight">\(k_2 : \neg A\)</span> and derive
<span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>1. Assume <span class="math notranslate nohighlight">\(k_1 : A\)</span>. We show <span class="math notranslate nohighlight">\(B\)</span> by implication elimination on <span class="math notranslate nohighlight">\(h_1\)</span> and
<span class="math notranslate nohighlight">\(k_1\)</span>.</p>
<p>2. Assume <span class="math notranslate nohighlight">\(k_2 : \neg A\)</span>. We show <span class="math notranslate nohighlight">\(B\)</span> by implication elimination on <span class="math notranslate nohighlight">\(h_2\)</span> and
<span class="math notranslate nohighlight">\(k_2\)</span>.</p>
</div></div><p>As an application of proof by cases, we show the remaining direction of De Morgan&#8217;s law.</p>
<div class="proof proof-type-theorem" id="id69">
<span id="thm-not-or-not-of-not-and"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.61</span>
        
            <span class="proof-title-name">(De Morgan&#8217;s law, &#8216;not or not of not and&#8217;)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(\neg(P\land Q)\to\neg P\lor\neg Q\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>Assume <span class="math notranslate nohighlight">\(h_1 : \neg(P\land Q)\)</span>. It suffices to prove <span class="math notranslate nohighlight">\(\neg P\lor\neg Q\)</span>.</p>
<p>Via proof by cases, it suffices to 1. assume <span class="math notranslate nohighlight">\(h_2 : P\)</span> and derive <span class="math notranslate nohighlight">\(\neg P\lor\neg Q\)</span>
and 2. assume <span class="math notranslate nohighlight">\(h_2 : \neg P\)</span> and derive <span class="math notranslate nohighlight">\(\neg P\lor\neg Q\)</span>.</p>
<ol class="arabic simple">
<li><p>Assume <span class="math notranslate nohighlight">\(h_2 : P\)</span>. By right or introduction, it suffices to prove <span class="math notranslate nohighlight">\(\neg Q\)</span>.
Assume <span class="math notranslate nohighlight">\(h_3 : Q\)</span>. By negation introduction, it suffices to prove <span class="math notranslate nohighlight">\(\bot\)</span>.
By false introduction on <span class="math notranslate nohighlight">\(h_1\)</span>, it suffices to prove <span class="math notranslate nohighlight">\(P\land Q\)</span>.
This follows by and introduction on <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
<li><p>We leave this part of the proof as an exercise for the reader.</p></li>
</ol>
</div></div><p>This method of reasoning is represented in Lean with the <code class="docutils literal notranslate"><span class="pre">by_cases</span></code> tactic. Depending on your
version of Lean, you may need to declare that propositions are &#8216;decidable&#8217; using the command
<code class="docutils literal notranslate"><span class="pre">local</span> <span class="pre">attribute</span> <span class="pre">[instance]</span> <span class="pre">classical.prop_decidable</span></code>. Fill in the <code class="docutils literal notranslate"><span class="pre">sorry</span></code> below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0A--%20BEGIN%0Alocal%20attribute%20%5Binstance%5D%20classical.prop_decidable%0A%0Atheorem%20not_or_not_of_not_and%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%2C%20%20%20%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%60.%20It%20suffices%20to%20prove%20%60%C2%ACp%20%E2%88%A8%20%C2%ACq%60.%0A%20%20--%20Via%20proof%20by%20cases%2C%20it%20suffices%20to%20prove%20we%20can%20derive%20%60%C2%ACp%20%E2%88%A8%20%C2%ACq%60%201.%20assuming%20%60h%E2%82%82%20%3A%20p%60%20and%202.%20assuming%20%60h%E2%82%82%20%3A%20%C2%ACp%60.%0A%20%20by_cases%20h%E2%82%82%20%3A%20p%2C%0A%20%20%7B%20right%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%E2%82%82%20%3A%20p%60.%20By%20right%20or%20introduction%2C%20it%20suffices%20to%20prove%20%60%C2%ACq%60.%0A%20%20%20%20assume%20h%E2%82%83%20%3A%20q%2C%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%E2%82%83%20%3A%20q%60.%20By%20negation%20introduction%2C%20it%20suffices%20to%20prove%20%60false%60.%0A%20%20%20%20apply%20h%E2%82%81%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20false%20introduction%20on%20%60h%E2%82%81%60%2C%20it%20suffices%20to%20prove%20%60p%20%E2%88%A7%20q%60.%0A%20%20%20%20exact%20%E2%9F%A8h%E2%82%82%2C%20h%E2%82%83%E2%9F%A9%2C%20%7D%2C%20%20%20%20%20%20--%20This%20follows%20by%20and%20introduction%20on%20%60h%E2%82%82%60%20and%20%60h%E2%82%83%60.%0A%20%20%7B%20sorry%20%7D%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2497.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">local</span> <span class="kn">attribute</span> <span class="o">[</span><span class="kd">instance</span><span class="o">]</span> <span class="n">classical.prop_decidable</span>

<span class="kd">theorem</span> <span class="n">not_or_not_of_not_and</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">),</span>    <span class="c1">-- Assume `h&#8321; : &#172;(p &#8743; q)`. It suffices to prove `&#172;p &#8744; &#172;q`.</span>
  <span class="c1">-- Via proof by cases, it suffices to prove we can derive `&#172;p &#8744; &#172;q` 1. assuming `h&#8322; : p` and 2. assuming `h&#8322; : &#172;p`.</span>
  <span class="n">by_cases</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">right</span><span class="o">,</span>                 <span class="c1">-- Assume `h&#8322; : p`. By right or introduction, it suffices to prove `&#172;q`.</span>
    <span class="k">assume</span> <span class="n">h&#8323;</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span>         <span class="c1">-- Assume `h&#8323; : q`. By negation introduction, it suffices to prove `false`.</span>
    <span class="n">apply</span> <span class="n">h&#8321;</span><span class="o">,</span>              <span class="c1">-- By false introduction on `h&#8321;`, it suffices to prove `p &#8743; q`.</span>
    <span class="n">exact</span> <span class="o">&#10216;</span><span class="n">h&#8322;</span><span class="o">,</span> <span class="n">h&#8323;</span><span class="o">&#10217;,</span> <span class="o">},</span>      <span class="c1">-- This follows by and introduction on `h&#8322;` and `h&#8323;`.</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>By iff introduction on our previous <a class="reference internal" href="#thm-not-and-of-not-or-not"><span class="std std-numref">Theorem 1.57</span></a> and
<a class="reference internal" href="#thm-not-or-not-of-not-and"><span class="std std-numref">Theorem 1.61</span></a>, we deduce the final iff De Morgan&#8217;s law.</p>
<div class="proof proof-type-theorem" id="id70">
<span id="thm-not-and-distrib"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.62</span>
        
            <span class="proof-title-name">(De Morgan&#8217;s law, &#8216;not and distrib&#8217;)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then
<span class="math notranslate nohighlight">\(\neg(P\land Q)\leftrightarrow\neg P\lor\neg Q\)</span>.</p>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20q%20%3A%20Prop%7D%0Atheorem%20not_or_not_of_not_and%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20%3A%3D%0A%CE%BB%20hnpq%2C%20or.elim%20(classical.em%20p)%20(%CE%BB%20hp%2C%20or.inr%20(%CE%BB%20hq%2C%20hnpq%20%E2%9F%A8hp%2C%20hq%E2%9F%A9))%20(%CE%BB%20hnp%2C%20or.inl%20hnp)%0Atheorem%20not_and_of_not_or_not%20%3A%20%C2%ACp%20%E2%88%A8%20%C2%ACq%20%E2%86%92%20%C2%AC(p%20%E2%88%A7%20q)%20%3A%3D%0A%CE%BB%20hnpnq%20hpq%2C%20or.elim%20hnpnq%20(%CE%BB%20hnp%2C%20hnp%20hpq.1)%20(%CE%BB%20hnq%2C%20hnq%20hpq.2)%0A--%20BEGIN%0Atheorem%20not_and_distrib%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%20%E2%86%94%20%C2%ACp%20%E2%88%A8%20%C2%AC%20q%20%3A%3D%0Abegin%0A%20%20split%2C%0A%20%20%7B%20exact%20not_or_not_of_not_and%2C%20%7D%2C%0A%20%20%7B%20exact%20not_and_of_not_or_not%2C%20%7D%2C%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2526.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_and_distrib</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">not_or_not_of_not_and</span><span class="o">,</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">not_and_of_not_or_not</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="double-negation">
<h3><span class="section-number">1.12.4. </span>Double negation<a class="headerlink" href="#double-negation" title="Permalink to this headline">&#182;</a></h3>
<div class="proof proof-type-theorem" id="id71">
<span id="thm-double-negation"></span>
    <div class="proof-title">
        <span class="proof-type">Theorem 1.63</span>
        
            <span class="proof-title-name">(Double negation)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> be a proposition. Then <span class="math notranslate nohighlight">\(\neg\neg P \leftrightarrow P\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By iff introduction, it suffices to prove 1. <span class="math notranslate nohighlight">\(\neg\neg P \to P\)</span> and 2. <span class="math notranslate nohighlight">\(P\to\neg\neg P\)</span>.</p>
<ol class="arabic simple">
<li><p>Assume <span class="math notranslate nohighlight">\(h_1 : \neg\neg P\)</span>. It suffices to prove <span class="math notranslate nohighlight">\(P\)</span>.
Via proof by cases, it suffices to prove <span class="math notranslate nohighlight">\(P\)</span> separately on the assumptions a. <span class="math notranslate nohighlight">\(h_2 : P\)</span>
and b. <span class="math notranslate nohighlight">\(h_2 : \neg P\)</span>.</p>
<ol class="loweralpha simple">
<li><p>Assume <span class="math notranslate nohighlight">\(h_2 : P\)</span>. We show <span class="math notranslate nohighlight">\(P\)</span> by reiteration on <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
<li><p>Assume <span class="math notranslate nohighlight">\(h_2 : \neg P\)</span>. By false elimination, it suffices to prove <span class="math notranslate nohighlight">\(\bot\)</span>.
We show <span class="math notranslate nohighlight">\(\bot\)</span> by false introduction on <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
</ol>
</li>
<li><p>This follows by <a class="reference internal" href="#thm-not-not-of-self"><span class="std std-numref">Theorem 1.52</span></a>.</p></li>
</ol>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7Bp%20%3A%20Prop%7D%0Atheorem%20not_not_of_self%20%3A%20p%20%E2%86%92%20%C2%AC%C2%ACp%20%3A%3D%20%CE%BB%20hp%20hnp%2C%20hnp%20hp%0Alocal%20attribute%20%5Binstance%5D%20classical.prop_decidable%0A--%20BEGIN%0Atheorem%20not_not%20%3A%20%C2%AC%C2%ACp%20%E2%86%94%20p%20%3A%3D%0Abegin%0A%20%20split%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20iff%20intro.%2C%20it%20suffices%20to%20prove%201.%20%60p%20%E2%86%92%20%C2%AC%C2%ACp%60%20and%202.%20%60%C2%AC%C2%ACp%20%E2%86%92%20p%60.%0A%20%20%7B%20assume%20h%E2%82%81%20%3A%20%C2%AC%C2%ACp%2C%20%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%AC%C2%ACp%60.%20It%20suffices%20to%20prove%20%60p%60.%0A%20%20%20%20by_cases%20h%E2%82%82%20%3A%20p%2C%20%20%20%20%20%20%20%20%20%20--%20We'll%20show%20%60p%60%20via%20proof%20by%20cases%20on%20%60p%60.%0A%20%20%20%20%7B%20exact%20h%E2%82%82%2C%20%20%7D%2C%20%20%20%20%20%20%20%20%20%20%20--%20Assume%20%60h%E2%82%82%20%3A%20p%60.%20The%20goal%2C%20%60p%60%20follows%20by%20reiteration%20on%20%60h%E2%82%82%60.%0A%20%20%20%20%7B%20exfalso%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20By%20false%20elimination%2C%20it%20suffices%20to%20prove%20%60false%60.%0A%20%20%20%20%20%20exact%20h%E2%82%81%20h%E2%82%82%2C%20%7D%2C%20%7D%2C%20%20%20%20%20%20--%20This%20follows%20by%20false%20introduction%20on%20%60h%E2%82%81%60%20and%20%60h%E2%82%82%60.%0A%20%20%7B%20exact%20not_not_of_self%2C%20%7D%2C%20--%20Goal%202.%20follows%20by%20a%20previously-proved%20theorem.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2566.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_not</span> <span class="o">:</span> <span class="bp">&#172;&#172;</span><span class="n">p</span> <span class="bp">&#8596;</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>                      <span class="c1">-- By iff intro., it suffices to prove 1. `p &#8594; &#172;&#172;p` and 2. `&#172;&#172;p &#8594; p`.</span>
  <span class="o">{</span> <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;&#172;</span><span class="n">p</span><span class="o">,</span>          <span class="c1">-- Assume `h&#8321; : &#172;&#172;p`. It suffices to prove `p`.</span>
    <span class="n">by_cases</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>          <span class="c1">-- We&#39;ll show `p` via proof by cases on `p`.</span>
    <span class="o">{</span> <span class="n">exact</span> <span class="n">h&#8322;</span><span class="o">,</span>  <span class="o">},</span>           <span class="c1">-- Assume `h&#8322; : p`. The goal, `p` follows by reiteration on `h&#8322;`.</span>
    <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span>                <span class="c1">-- By false elimination, it suffices to prove `false`.</span>
      <span class="n">exact</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="o">},</span> <span class="o">},</span>      <span class="c1">-- This follows by false introduction on `h&#8321;` and `h&#8322;`.</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">not_not_of_self</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- Goal 2. follows by a previously-proved theorem.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>As an example application, we give another proof of
:<a class="reference internal" href="#thm-not-or-not-of-not-and"><span class="std std-numref">Theorem 1.61</span></a>, this time using double negation instead of
proof by cases. Recall that <code class="docutils literal notranslate"><span class="pre">not_or_distrib</span></code> is our constructive result <code class="docutils literal notranslate"><span class="pre">&#172;(a</span> <span class="pre">&#8744;</span> <span class="pre">b)</span> <span class="pre">&#8596;</span> <span class="pre">&#172;a</span> <span class="pre">&#8743;</span> <span class="pre">&#172;b</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20logic.basic%0Avariables%20%7Bp%20q%20%3A%20Prop%7D%0Alocal%20attribute%20%5Binstance%5D%20classical.prop_decidable%0A--%20BEGIN%0Aexample%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A8%20%C2%AC%20q%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%2C%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%60.%20It%20sfufice%20to%20prove%20%60%C2%ACp%20%E2%88%A8%20%C2%ACq%60.%0A%20%20have%20h%E2%82%82%20%3A%20%C2%AC%C2%AC(%C2%ACp%20%E2%88%A8%20%C2%ACq)%20%E2%86%94%20%C2%ACp%20%E2%88%A8%20%C2%ACq%2C%20from%20not_not%2C%20--%20By%20double%20negation%2C%20we%20have%20%60%C2%AC%C2%AC(%C2%ACp%20%E2%88%A8%20%C2%ACq)%20%E2%86%94%20%C2%ACp%20%E2%88%A8%20%C2%ACq%60.%0A%20%20rw%20%E2%86%90h%E2%82%82%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20Rewriting%20with%20%60h%E2%82%82%60%2C%20the%20goal%20is%20to%20show%20%60%C2%AC%C2%AC(%C2%ACp%20%E2%88%A8%20%C2%ACq)%60.%0A%20%20rw%20not_or_distrib%2C%20%20%20%20%20%20--%20Rewriting%20with%20%60not_or_distrib%60%2C%20the%20goal%20is%20to%20show%20%60%C2%AC(%C2%AC%C2%ACp%20%E2%88%A7%20%C2%AC%C2%ACq)%60%0A%20%20repeat%20%7B%20rw%20not_not%2C%20%7D%2C%20--%20Repeatedly%20rewriting%20with%20double%20negation%2C%20the%20goal%20is%20to%20show%20%60%C2%AC(p%20%E2%88%A7%20q)%60.%0A%20%20show%20%C2%AC(p%20%E2%88%A7%20q)%2C%20from%20h%E2%82%81%2C%20--%20We%20show%20%60%C2%AC(p%20%E2%88%A7%20q)%60%20from%20%60h%E2%82%81%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2588.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">),</span> <span class="c1">-- Assume `h&#8321; : &#172;(p &#8743; q)`. It sfufice to prove `&#172;p &#8744; &#172;q`.</span>
  <span class="k">have</span> <span class="n">h&#8322;</span> <span class="o">:</span> <span class="bp">&#172;&#172;</span><span class="o">(</span><span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">not_not</span><span class="o">,</span> <span class="c1">-- By double negation, we have `&#172;&#172;(&#172;p &#8744; &#172;q) &#8596; &#172;p &#8744; &#172;q`.</span>
  <span class="n">rw</span> <span class="bp">&#8592;</span><span class="n">h&#8322;</span><span class="o">,</span>                 <span class="c1">-- Rewriting with `h&#8322;`, the goal is to show `&#172;&#172;(&#172;p &#8744; &#172;q)`.</span>
  <span class="n">rw</span> <span class="n">not_or_distrib</span><span class="o">,</span>      <span class="c1">-- Rewriting with `not_or_distrib`, the goal is to show `&#172;(&#172;&#172;p &#8743; &#172;&#172;q)`</span>
  <span class="n">repeat</span> <span class="o">{</span> <span class="n">rw</span> <span class="n">not_not</span><span class="o">,</span> <span class="o">},</span> <span class="c1">-- Repeatedly rewriting with double negation, the goal is to show `&#172;(p &#8743; q)`.</span>
  <span class="k">show</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">),</span> <span class="k">from</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="c1">-- We show `&#172;(p &#8743; q)` from `h&#8321;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="proof-by-contradiction">
<h3><span class="section-number">1.12.5. </span>Proof by contradiction<a class="headerlink" href="#proof-by-contradiction" title="Permalink to this headline">&#182;</a></h3>
<p>Negation introduction is the (derived) rule that <span class="math notranslate nohighlight">\(\neg P\)</span> is proved by assuming <span class="math notranslate nohighlight">\(P\)</span>
and deriving <span class="math notranslate nohighlight">\(\bot\)</span>. Proof by contradiction (also called <em>reductio ad absurdum</em>) is a similar
result, formed by subsituting <span class="math notranslate nohighlight">\(Q\)</span> for <span class="math notranslate nohighlight">\(\neg P\)</span> and using double negation.</p>
<div class="proof proof-type-theorem" id="id72">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.64</span>
        
            <span class="proof-title-name">(Proof by contradiction)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(Q\)</span> be a proposition. To prove <span class="math notranslate nohighlight">\(Q\)</span>, it suffices to assume <span class="math notranslate nohighlight">\(\neg Q\)</span> and
derive <span class="math notranslate nohighlight">\(\bot\)</span>.</p>
</div></div><p>This theorem is really just a restatement of one direction of the double negation result.</p>
<div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By left iff elimination on the double negation result, <a class="reference internal" href="#thm-double-negation"><span class="std std-numref">Theorem 1.63</span></a>,
we have <span class="math notranslate nohighlight">\(\neg\neg Q \to Q\)</span>.</p>
<p>By implication introduction, this means <span class="math notranslate nohighlight">\(Q\)</span> follows on the assumption <span class="math notranslate nohighlight">\(\neg\neg Q\)</span>
By definition of <span class="math notranslate nohighlight">\(\neg\)</span>, to prove <span class="math notranslate nohighlight">\(\neg\neg Q\)</span> is to assume <span class="math notranslate nohighlight">\(\neg Q\)</span> and
derive <span class="math notranslate nohighlight">\(\bot\)</span>.</p>
</div></div><p>In Lean, we invoke proof by contradiction using the <code class="docutils literal notranslate"><span class="pre">by_contradiction</span></code> tactic. We see this in
use below in yet another proof of <a class="reference internal" href="#thm-not-or-not-of-not-and"><span class="std std-numref">Theorem 1.61</span></a></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20logic.basic%0Avariables%20%7Bp%20q%20%3A%20Prop%7D%0Alocal%20attribute%20%5Binstance%5D%20classical.prop_decidable%0A--%20BEGIN%0Aexample%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A8%20%C2%AC%20q%20%3A%3D%0Abegin%0A%20%20assume%20h%E2%82%81%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%2C%20%20%20%20%20%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%60.%20It%20sfufice%20to%20prove%20%60%C2%ACp%20%E2%88%A8%20%C2%ACq%60.%0A%20%20by_contradiction%20h%E2%82%82%2C%20%20%20%20%20%20%20--%20For%20a%20contradiciton%2C%20assume%20%60h%E2%82%82%20%3A%20%C2%AC(%C2%ACp%20%E2%88%A8%20%C2%ACq)%60.%20It%20suffices%20to%20prove%20%60false%60.%0A%20%20rw%20not_or_distrib%20at%20h%E2%82%82%2C%20%20%20--%20Rewriting%20using%20De%20Morgan's%20law%20%60not_or_distrib%60%2C%20%60h%E2%82%82%60%20is%20%60%C2%AC%C2%ACp%20%E2%88%A7%20%C2%AC%C2%ACq%60.%0A%20%20repeat%20%7Brw%20not_not%20at%20h%E2%82%82%7D%2C%20--%20Repeatedly%20using%20double%20negation%2C%20%60h%E2%82%82%60%20is%20%60p%20%E2%88%A7%20q%60.%0A%20%20show%20false%2C%20from%20h%E2%82%81%20h%E2%82%82%2C%20%20%20%20--%20We%20show%20false%20by%20false%20introduction%20on%20%60h%E2%82%81%60%20and%20%60h%E2%82%82%60.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2633.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">),</span>      <span class="c1">-- Assume `h&#8321; : &#172;(p &#8743; q)`. It sfufice to prove `&#172;p &#8744; &#172;q`.</span>
  <span class="n">by_contradiction</span> <span class="n">h&#8322;</span><span class="o">,</span>       <span class="c1">-- For a contradiciton, assume `h&#8322; : &#172;(&#172;p &#8744; &#172;q)`. It suffices to prove `false`.</span>
  <span class="n">rw</span> <span class="n">not_or_distrib</span> <span class="n">at</span> <span class="n">h&#8322;</span><span class="o">,</span>   <span class="c1">-- Rewriting using De Morgan&#39;s law `not_or_distrib`, `h&#8322;` is `&#172;&#172;p &#8743; &#172;&#172;q`.</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">not_not</span> <span class="n">at</span> <span class="n">h&#8322;</span><span class="o">},</span> <span class="c1">-- Repeatedly using double negation, `h&#8322;` is `p &#8743; q`.</span>
  <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span>    <span class="c1">-- We show false by false introduction on `h&#8321;` and `h&#8322;`.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="proof-by-contrapositive">
<h3><span class="section-number">1.12.6. </span>Proof by contrapositive<a class="headerlink" href="#proof-by-contrapositive" title="Permalink to this headline">&#182;</a></h3>
<p>Recall that the contrapositive of a conditional <span class="math notranslate nohighlight">\(P\to Q\)</span> is the proposition
<span class="math notranslate nohighlight">\(\neg Q\to\neg P\)</span>. Using constructive reasoning, we previously proved
<a class="reference internal" href="#thm-mt"><span class="std std-numref">Theorem 1.53</span></a>, that <span class="math notranslate nohighlight">\((P\to Q)\to(\neg Q\to\neg P)\)</span>.</p>
<p>By proving the converse of this result we will have, by iff introduction,
<span class="math notranslate nohighlight">\((\neg Q\to\neg P) \leftrightarrow (P\to Q)\)</span>.</p>
<div class="proof proof-type-theorem" id="id73">

    <div class="proof-title">
        <span class="proof-type">Theorem 1.65</span>
        
            <span class="proof-title-name">(Proof by contrapositive, &#8216;not imp not&#8217;)</span>
        
    </div><div class="proof-content">
<p>Let <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> be propositions. Then <span class="math notranslate nohighlight">\(\neg Q\to\neg P \leftrightarrow P\to Q\)</span>.</p>
</div></div><div class="proof proof-type-proof">

    <div class="proof-title">
        <span class="proof-type">Proof </span>
        
    </div><div class="proof-content">
<p>By iff introduction, it suffices to prove 1. <span class="math notranslate nohighlight">\((\neg Q\to\neg P)\to (P\to Q)\)</span>. and
2. <span class="math notranslate nohighlight">\((P\to Q)\to(\neg Q\to\neg P)\)</span>.</p>
<ol class="arabic simple">
<li><p>Assume <span class="math notranslate nohighlight">\(h_1 : \neg Q\to\neg P\)</span>. It suffices to prove <span class="math notranslate nohighlight">\(P\to Q\)</span>.
Assume <span class="math notranslate nohighlight">\(h_2 : P\)</span>. It suffices to prove <span class="math notranslate nohighlight">\(Q\)</span>.
For a contradiction, assume <span class="math notranslate nohighlight">\(h_3 : \neg Q\)</span>. It suffices to prove <span class="math notranslate nohighlight">\(\bot\)</span>.
We have <span class="math notranslate nohighlight">\(h_4 : \neg P\)</span> from implication elimination on <span class="math notranslate nohighlight">\(h_1\)</span> and <span class="math notranslate nohighlight">\(h_3\)</span>.
We show <span class="math notranslate nohighlight">\(\bot\)</span> by false introduction on <span class="math notranslate nohighlight">\(h_4\)</span> and <span class="math notranslate nohighlight">\(h_2\)</span>.</p></li>
<li><p>We show <span class="math notranslate nohighlight">\((P\to Q)\to(\neg Q\to\neg P)\)</span> by <a class="reference internal" href="#thm-mt"><span class="std std-numref">Theorem 1.53</span></a>, modus tollens.</p></li>
</ol>
</div></div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20logic.basic%0Avariables%20%7Bp%20q%20%3A%20Prop%7D%0Alocal%20attribute%20%5Binstance%5D%20classical.prop_decidable%0Anamespace%20hidden%0A--%20BEGIN%0Atheorem%20not_imp_not%20%3A%20(%C2%ACq%20%E2%86%92%20%C2%ACp)%20%E2%86%94%20(p%20%E2%86%92%20q)%20%3A%3D%0Abegin%0A%20%20split%2C%20--%20By%20iff%20intro.%2C%20it%20suffices%20to%20prove%201.%20%60%C2%ACq%20%E2%86%92%20%C2%ACp%20%E2%86%92%20p%20%E2%86%92%20q%60%20and%202.%20%60p%20%E2%86%92%20q%20%E2%86%92%20%C2%ACq%20%E2%86%92%20%C2%ACp%60.%0A%20%20%7B%20intros%20h%E2%82%81%20h%E2%82%82%2C%20--%20Assume%20%60h%E2%82%81%20%3A%20%C2%ACq%20%E2%86%92%20%C2%ACp%60%2C%20%60h%E2%82%82%20%3A%20p%60.%20It%20suffices%20to%20prove%20%60q%60.%0A%20%20%20%20by_contradiction%20h%E2%82%83%2C%20--%20For%20a%20contradiction%2C%20assume%20%60h%E2%82%83%20%3A%20%C2%ACq%60.%20It%20suffices%20to%20prove%20%60false%60.%0A%20%20%20%20have%20h%E2%82%84%20%3A%20%C2%ACp%2C%20from%20h%E2%82%81%20h%E2%82%83%2C%20--%20We%20have%20%60h%E2%82%84%20%3A%20%C2%ACp%60%20by%20implication%20elimination%20on%20%60h%E2%82%81%60%20and%20%60h%E2%82%83%60.%0A%20%20%20%20show%20false%2C%20from%20h%E2%82%84%20h%E2%82%82%2C%20--%20We%20show%20%60false%60%20by%20false%20introduction%20on%20%60h%E2%82%84%60%20and%20%60h%E2%82%82%60.%0A%20%20%7D%2C%0A%20%20%7B%20exact%20mt%20%7D%2C%20--%20We%20show%20%60(p%20%E2%86%92%20q)%20%E2%86%92%20(%C2%ACq%20%E2%86%92%20%C2%ACp)%60%20by%20modus%20tollens.%0Aend%0A--%20END%0Aend%20hidden" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2676.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">not_imp_not</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="n">p</span> <span class="bp">&#8594;</span> <span class="n">q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span> <span class="c1">-- By iff intro., it suffices to prove 1. `&#172;q &#8594; &#172;p &#8594; p &#8594; q` and 2. `p &#8594; q &#8594; &#172;q &#8594; &#172;p`.</span>
  <span class="o">{</span> <span class="n">intros</span> <span class="n">h&#8321;</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="c1">-- Assume `h&#8321; : &#172;q &#8594; &#172;p`, `h&#8322; : p`. It suffices to prove `q`.</span>
    <span class="n">by_contradiction</span> <span class="n">h&#8323;</span><span class="o">,</span> <span class="c1">-- For a contradiction, assume `h&#8323; : &#172;q`. It suffices to prove `false`.</span>
    <span class="k">have</span> <span class="n">h&#8324;</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="n">p</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8321;</span> <span class="n">h&#8323;</span><span class="o">,</span> <span class="c1">-- We have `h&#8324; : &#172;p` by implication elimination on `h&#8321;` and `h&#8323;`.</span>
    <span class="k">show</span> <span class="n">false</span><span class="o">,</span> <span class="k">from</span> <span class="n">h&#8324;</span> <span class="n">h&#8322;</span><span class="o">,</span> <span class="c1">-- We show `false` by false introduction on `h&#8324;` and `h&#8322;`.</span>
  <span class="o">},</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">mt</span> <span class="o">},</span> <span class="c1">-- We show `(p &#8594; q) &#8594; (&#172;q &#8594; &#172;p)` by modus tollens.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>As an example, we&#8217;ll use proof by contrapositive to give another proof of
<a class="reference internal" href="#thm-not-or-not-of-not-and"><span class="std std-numref">Theorem 1.61</span></a>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20logic.basic%0Avariables%20%7Bp%20q%20%3A%20Prop%7D%0Alocal%20attribute%20%5Binstance%5D%20classical.prop_decidable%0A--%20BEGIN%0Aexample%20%3A%20%C2%AC(p%20%E2%88%A7%20q)%20%E2%86%92%20%C2%ACp%20%E2%88%A8%20%C2%AC%20q%20%3A%3D%0Abegin%0A%20%20rw%20%E2%86%90not_imp_not%2C%20--%20It%20suffices%20to%20prove%20the%20contrapositive%2C%20%60%C2%AC(%C2%ACp%20%E2%88%A8%20%C2%ACq)%20%E2%86%92%20%C2%AC%C2%AC(p%20%E2%88%A7%20q)%60.%0A%20%20rw%20not_or_distrib%2C%20--%20By%20De%20Morgan's%20Law%20%60not_or_distrib%60%2C%20it%20suffices%20to%20prove%20%60%C2%AC%C2%ACp%20%E2%88%A7%20%C2%AC%C2%ACq%20%E2%86%92%20%C2%AC%C2%AC(p%20%E2%88%A7%20q)%60.%0A%20%20repeat%20%7Brw%20not_not%7D%2C%20--%20By%20repeated%20double%20negation%2C%20it%20suffices%20to%20prove%20%60p%20%E2%88%A7%20q%20%E2%86%92%20p%20%E2%88%A7%20q%60.%0A%20%20exact%20id%2C%20--%20This%20follows%20by%20%60id%60%2C%20the%20reflexivity%20of%20implication.%0Aend%0A--%20END" target="_blank" tryitfile="../examples/prop_logic_theory/unnamed_2699.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">p</span> <span class="bp">&#8743;</span> <span class="n">q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">p</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span> <span class="n">q</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="bp">&#8592;</span><span class="n">not_imp_not</span><span class="o">,</span> <span class="c1">-- It suffices to prove the contrapositive, `&#172;(&#172;p &#8744; &#172;q) &#8594; &#172;&#172;(p &#8743; q)`.</span>
  <span class="n">rw</span> <span class="n">not_or_distrib</span><span class="o">,</span> <span class="c1">-- By De Morgan&#39;s Law `not_or_distrib`, it suffices to prove `&#172;&#172;p &#8743; &#172;&#172;q &#8594; &#172;&#172;(p &#8743; q)`.</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">rw</span> <span class="n">not_not</span><span class="o">},</span> <span class="c1">-- By repeated double negation, it suffices to prove `p &#8743; q &#8594; p &#8743; q`.</span>
  <span class="n">exact</span> <span class="n">id</span><span class="o">,</span> <span class="c1">-- This follows by `id`, the reflexivity of implication.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">MTH1001 in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. The Theory of Propositional Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#propositions-and-propositional-variables">1.1. Propositions and propositional variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#derivations-and-rules-of-inference">1.2. Derivations and rules of inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conjunction">1.3. Conjunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reiteration">1.4. Reiteration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implication">1.5. Implication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#theorems">1.6. Theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#if-and-only-if">1.7. If and only if</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rewriting">1.8. Rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#propositional-extensionality-and-rewriting">1.9. Propositional extensionality and rewriting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#disjunction">1.10. Disjunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#false-and-negation">1.11. False and negation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classical-reasoning">1.12. Classical reasoning</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="prop_logic_lean_summary.html">2. Propositional Logic Lean Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="pred_logic.html">3. Predicate Logic</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="mth1001_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Gihan Marasingha.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/prop_logic_theory.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>